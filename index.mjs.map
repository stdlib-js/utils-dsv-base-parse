{"version":3,"file":"index.mjs","sources":["../lib/defaults.js","../lib/states/state2enum.js","../lib/states/closed.js","../lib/states/comment.js","../lib/states/error.js","../lib/states/max.js","../lib/states/escape.js","../lib/states/field.js","../lib/states/init.js","../lib/states/invalid_quote_end.js","../lib/states/quote_end.js","../lib/states/quoted_escape.js","../lib/states/quoted_field.js","../lib/states/skip.js","../lib/states/skipped_comment.js","../lib/states/skipped_escape.js","../lib/states/skipped_field.js","../lib/states/skipped_invalid_quote_end.js","../lib/states/skipped_quote_end.js","../lib/states/skipped_quoted_escape.js","../lib/states/skipped_quoted_field.js","../lib/states/index.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport noop from '@stdlib/utils-noop';\n\n\n// FUNCTIONS //\n\n/**\n* Throws a provided exception.\n*\n* @private\n* @param {Error} err - error object\n* @throws {Error} exception\n*/\nfunction throwError( err ) {\n\tthrow err;\n}\n\n\n// MAIN //\n\n/**\n* Returns default options.\n*\n* @private\n* @returns {Object} default options\n*\n* @example\n* var o = defaults();\n* // returns {...}\n*/\nfunction defaults() {\n\treturn {\n\t\t// Character sequence appearing at the beginning of a row which demarcates that the row content should be parsed as a commented line. A commented line ends upon encountering the first newline character sequence, regardless of whether that newline character sequence is preceded by an escape character sequence.\n\t\t'comment': '',\n\n\t\t// Character sequence separating record fields (e.g., use `','` for CSV and use `'\\t'` for TSV).\n\t\t'delimiter': ',',\n\n\t\t// Flag indicating how quote sequences should be escaped within a quoted field. When `true`, a quote sequence must be escaped by another quote sequence. When `false`, a quote sequence must be escaped by the escape sequence.\n\t\t'doublequote': true,\n\n\t\t// Character sequence for escaping character sequences having special meaning (i.e., delimiter, newline, escape, and comment outside of quoted fields, and the quote sequence within quoted fields when `doublequote` is `false`).\n\t\t'escape': '',\n\n\t\t// Flag indicating whether to trim leading whitespace from field values. If `false`, leading whitespace is not trimmed (e.g., `a, b, c` parses as `[ 'a', ' b', ' c' ]`). If `true`, leading whitespace is trimmed (e.g., `a, b, c` parses as `[ 'a', 'b', 'c' ]`).\n\t\t'ltrim': false,\n\n\t\t// Maximum number of records to process.\n\t\t'maxRows': 1e308,\n\n\t\t// Character sequence separating rows.\n\t\t'newline': '\\r\\n',\n\n\t\t// Callback to be invoked upon closing the parser.\n\t\t'onClose': noop,\n\n\t\t// Callback to be invoked upon processing a field.\n\t\t'onColumn': noop,\n\n\t\t// Callback to be invoked upon processing a commented line.\n\t\t'onComment': null,\n\n\t\t// Callback to be invoked upon encountering an unrecoverable parse error.\n\t\t'onError': throwError,\n\n\t\t// Callback to be invoked upon processing a record.\n\t\t'onRow': noop,\n\n\t\t// Callback to be invoked upon skipping a line.\n\t\t'onSkip': null,\n\n\t\t// When `strict` is `false`, a callback to be invoked upon encountering invalid DSV.\n\t\t'onWarn': null,\n\n\t\t// Character sequence demarcating the beginning and ending of a quoted field.\n\t\t'quote': '\"',\n\n\t\t// Flag indicating whether to enable special processing of quote character sequences (i.e., whether a quote sequence should demarcate a quoted field).\n\t\t'quoting': true,\n\n\t\t// Array-like object for storing the field values of the most recently processed record. This allows reusing memory and avoiding copies upon invocation of the `onRow` callback.\n\t\t'rowBuffer': [],\n\n\t\t// Flag indicating whether to trim trailing whitespace from field values. If `false`, trailing whitespace is not trimmed (e.g., `a ,b , c` parses as `[ 'a ', 'b ', ' c' ]`). If `true`, trailing whitespace is trimmed (e.g., `a ,b ,c` parses as `[ 'a', 'b', 'c' ]`).\n\t\t'rtrim': false,\n\n\t\t// Character sequence appearing at the beginning of a row which demarcates that the row content should be skipped.\n\t\t'skip': '',\n\n\t\t// Flag indicating whether to skip over rows which are either empty or containing only whitespace.\n\t\t'skipBlankRows': false,\n\n\t\t// Callback whose return value indicates whether to skip over a row.\n\t\t'skipRow': null,\n\n\t\t// Flag indicating whether to raise an exception upon encountering invalid DSV.\n\t\t'strict': true,\n\n\t\t// Flag indicating whether to trim leading whitespace in commented lines.\n\t\t'trimComment': true,\n\n\t\t// List of characters to be treated as whitespace.\n\t\t'whitespace': [ ' ' ]\n\t};\n}\n\n\n// EXPORTS //\n\nexport default defaults;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport enum2state from './enum2state.json';\n\n\n// FUNCTIONS //\n\n/**\n* Returns a table mapping state names to enumeration constants.\n*\n* @private\n* @returns {Object} mapping table\n*/\nfunction table() {\n\tvar out;\n\tvar i;\n\n\tout = {};\n\tfor ( i = 0; i < enum2state.length; i++ ) {\n\t\tout[ enum2state[ i ] ] = i;\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Table mapping state names to enumeration constants.\n*\n* @private\n* @name state2enum\n* @type {Object}\n*/\nvar state2enum = table(); // eslint-disable-line vars-on-top\n\n\n// EXPORTS //\n\nexport default state2enum;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\n// Possible transition states...\nvar CLOSED = state2enum[ 'closed' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for closing a parser.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next() {\n\t\tparser._changeState( CLOSED );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:comment' );\n\n// Possible transition states...\nvar INIT = state2enum[ 'init' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a commented line.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar newlineLastIndex;\n\tvar newline;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t// Check for the end of the commented line...\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\n// Possible transition states...\nvar ERROR = state2enum[ 'error' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for a parser error state.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next() {\n\t\tparser._changeState( ERROR );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns the maximum value.\n*\n* @private\n* @param {NonNegativeInteger} x - first value\n* @param {NonNegativeInteger} y - second value\n* @returns {NonNegativeInteger} maximum value\n*\n* @example\n* var v = max( 2, 3 );\n* // returns 3\n*\n* @example\n* var v = max( 3, 2 );\n* // returns 3\n*\n* @example\n* var v = max( 2, 2 );\n* // returns 2\n*/\nfunction max( x, y ) {\n\treturn ( x < y ) ? y : x;\n}\n\n\n// EXPORTS //\n\nexport default max;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport maximum from './max.js';\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:escape' );\n\n// Possible transition states...\nvar ERROR = state2enum[ 'error' ];\nvar FIELD = state2enum[ 'field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing an escape sequence.\n*\n* ## Notes\n*\n* -   An escape sequence escapes the delimiter, newline, and escape sequences in **non-quoted** fields.\n* -   An escape sequence escapes comment and skip sequences in **non-quoted** fields when an escape sequence occurs at the beginning of a record.\n* -   In strict mode, if not immediately followed by a special character sequence, then the parser raises an exception.\n* -   In non-strict mode, if not immediately followed by a special character sequence, then the escape sequence has no special meaning and is considered a normal character sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar commentLastIndex;\n\tvar escapeLastIndex;\n\tvar skipLastIndex;\n\tvar escapeLength;\n\tvar delimiter;\n\tvar newline;\n\tvar comment;\n\tvar escape;\n\tvar strict;\n\tvar skip;\n\tvar max;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tcommentLastIndex = parser._commentLastIndex;\n\tcomment = parser._comment;\n\n\tskipLastIndex = parser._skipLastIndex;\n\tskip = parser._skip;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescapeLength = parser._escapeLength;\n\tescape = parser._escape;\n\n\tstrict = parser._strict;\n\n\tmax = maximum( maximum( delimiterLastIndex, newlineLastIndex ), escapeLastIndex ); // eslint-disable-line max-len\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar cursor = parser._cursor;\n\t\tvar idx = parser._eidx; // position of last escape character\n\t\tvar d = cursor - idx;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\td === delimiterLastIndex &&\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._copyWithin( idx-escapeLastIndex, idx+1, delimiterLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\td === newlineLastIndex &&\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._copyWithin( idx-escapeLastIndex, idx+1, newlineLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for an escape sequence.\n\t\t*/\n\t\tif (\n\t\t\td === escapeLastIndex &&\n\t\t\tch === escape[ escapeLastIndex ] &&\n\t\t\tparser._scan( escape, escapeLastIndex )\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._copyWithin( idx-escapeLastIndex, idx+1, escapeLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a comment sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Comment sequences only have special meaning when appearing at the beginning of a row.\n\t\t*/\n\t\tif (\n\t\t\tcomment &&                                 // user specified a comment character sequence, so should check for comments\n\t\t\tcursor-commentLastIndex === 0 &&           // only search the first character(s) of the row\n\t\t\tch === comment[ commentLastIndex ] &&      // we have a potential match\n\t\t\tparser._scan( comment, commentLastIndex )  // we found a match\n\t\t) {\n\t\t\tdebug( 'Comment.' );\n\t\t\tparser._copyWithin( idx-commentLastIndex, idx+1, commentLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a skip sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Skip sequences only have special meaning when appearing at the beginning of a row.\n\t\t*/\n\t\tif (\n\t\t\tskip &&                                 // user specified a skip character sequence, so should check for a skipped line\n\t\t\tcursor-skipLastIndex === 0 &&           // only search the first character(s) of the row\n\t\t\tch === skip[ skipLastIndex ] &&         // we have a potential match\n\t\t\tparser._scan( skip, skipLastIndex )     // we found a match\n\t\t) {\n\t\t\tdebug( 'Skip.' );\n\t\t\tparser._copyWithin( idx-skipLastIndex, idx+1, skipLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a non-special character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In strict mode, field separators, row separators, and escaped sequences must immediately follow an escape sequence. At some point, we'll have processed a greater number of characters than exists in any of the special character sequences, meaning that none of those sequences immediately follow the escape sequence which led to the current state. Once this happens, we're in an invalid state and must raise an exception, as not clear how the parser should interpret the preceding values (e.g., was the preceding escape sequence supposed to be escaped? was the preceding escape sequence a mistake and should be ignored? are we missing a delimiter or newline sequence? etc.).\n\t\t* -   In non-strict mode, we assume that the escape sequence is a normal character sequence.\n\t\t*/\n\t\tif ( d >= max ) {\n\t\t\tif ( strict ) {\n\t\t\t\tdebug( 'Error.' );\n\t\t\t\tparser._setErrorState( 'INVALID_ESCAPE' )._changeState( ERROR );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Return to normal field processing:\n\t\t\tdebug( 'Escape sequence is not followed by a special character sequence.' );\n\t\t\tparser._raiseWarning( 'INVALID_ESCAPE' )._push( ch )._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:field' );\n\n// Possible transition states...\nvar ESCAPE = state2enum[ 'escape' ];\nvar FIELD = state2enum[ 'field' ];\nvar INIT = state2enum[ 'init' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a field.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar delimiter;\n\tvar newline;\n\tvar quoting;\n\tvar escape;\n\tvar strict;\n\tvar quote;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tquoting = parser._quoting;\n\tstrict = parser._strict;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar idx = parser._cursor - parser._cidx + 1;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for an escape character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   An escape sequence escapes the delimiter, newline, and escape sequences in **non-quoted** fields.\n\t\t* -   When `doublequote` is `false`, the escape sequence escapes quote sequences within **quoted** fields.\n\t\t* -   In strict mode, if not immediately followed by a special character sequence, then the parser raises an exception.\n\t\t* -   In non-strict mode, if not immediately followed by a special character sequence, then the escape sequence has no special meaning.\n\t\t*/\n\t\tif (\n\t\t\tch === escape[ escapeLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( escape, escapeLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( ESCAPE );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a quote character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tidx-quoteLastIndex === 0 &&           // only search the first character(s) of the field\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tif ( quoting ) {\n\t\t\t\t// Rewind the cursor to point to the last character before the quote character sequence:\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._rewind( quoteLastIndex )._changeState( QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\tparser._push( ch );\n\t\t\treturn;\n\t\t}\n\t\t/**\n\t\t* Check for a quote character sequence (non-strict mode).\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In non-strict mode, a quote character sequence is allowed to start after whitespace (e.g., `a,  \"b\",  c`).\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tstrict === false &&                   // non-strict mode\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tif ( quoting && parser._isWhitespace( parser._cidx, parser._cursor-quoteLastIndex ) ) {\n\t\t\t\t// Rewind the cursor to point to the last character of the preceding field:\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._raiseWarning( 'INVALID_OPENING_QUOTE' )\n\t\t\t\t\t._rewind( idx )\n\t\t\t\t\t._changeState( QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\tparser._push( ch );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the delimiter character sequence:\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._rewind( delimiterLastIndex )._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:init' );\n\n// Possible transition states...\nvar COMMENT = state2enum[ 'comment' ];\nvar FIELD = state2enum[ 'field' ];\nvar ESCAPE = state2enum[ 'escape' ];\nvar INIT = state2enum[ 'init' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\nvar SKIP = state2enum[ 'skip' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing the initial characters of a row.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar commentLastIndex;\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar skipLastIndex;\n\tvar delimiter;\n\tvar newline;\n\tvar comment;\n\tvar quoting;\n\tvar escape;\n\tvar strict;\n\tvar quote;\n\tvar skip;\n\n\tcommentLastIndex = parser._commentLastIndex;\n\tcomment = parser._comment;\n\n\tskipLastIndex = parser._skipLastIndex;\n\tskip = parser._skip;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tquoting = parser._quoting;\n\tstrict = parser._strict;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar idx = parser._cursor + 1;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for the start of a commented line.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In order for a row to be considered a commented line, the comment sequence must be the first character(s) of the field.\n\t\t*/\n\t\tif (\n\t\t\tcomment &&                                // user specified a comment character sequence, so should check for comments\n\t\t\tidx-commentLastIndex === 0 &&             // only search the first character(s) of the first field\n\t\t\tch === comment[ commentLastIndex ] &&     // we have a potential comment match\n\t\t\tparser._scan( comment, commentLastIndex ) // we found a match\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the comment character sequence:\n\t\t\tdebug( 'Comment.' );\n\t\t\tparser._rewind( commentLastIndex )._changeState( COMMENT );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for the start of a skipped line.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In order for a row to be considered a skipped line, the skip sequence must be the first character(s) of the field.\n\t\t*/\n\t\tif (\n\t\t\tskip &&                                // user specified a skip character sequence, so should check for skipped lines\n\t\t\tidx-skipLastIndex === 0 &&             // only search the first character(s) of the first field\n\t\t\tch === skip[ skipLastIndex ] &&        // we have a potential match\n\t\t\tparser._scan( skip, skipLastIndex )    // we found a match\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the skip character sequence:\n\t\t\tdebug( 'Skip.' );\n\t\t\tparser._rewind( skipLastIndex )._changeState( SKIP );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for an escape character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   An escape sequence escapes the delimiter, newline, and escape sequences in **non-quoted** fields.\n\t\t* -   An escape sequence escapes comment and skip sequences in **non-quoted** fields when an escape sequence occurs at the beginning of a record.\n\t\t* -   When `doublequote` is `false`, the escape sequence escapes quote sequences within **quoted** fields.\n\t\t* -   In strict mode, if not immediately followed by a special character sequence, then the parser raises an exception.\n\t\t* -   In non-strict mode, if not immediately followed by a special character sequence, then the escape sequence has no special meaning.\n\t\t*/\n\t\tif (\n\t\t\tch === escape[ escapeLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( escape, escapeLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( ESCAPE );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a quote character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tidx-quoteLastIndex === 0 &&           // only search the first character(s) of the field\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tif ( quoting ) {\n\t\t\t\t// Rewind the cursor to point to the last character before the quote character sequence:\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._rewind( quoteLastIndex )._changeState( QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\tparser._push( ch );\n\t\t\treturn;\n\t\t}\n\t\t/**\n\t\t* Check for a quote character sequence (non-strict mode).\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In non-strict mode, a quote character sequence is allowed to start after whitespace (e.g., `a,  \"b\",  c`).\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tstrict === false &&                   // non-strict mode\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tif ( quoting && parser._isWhitespace( 0, parser._cursor-quoteLastIndex ) ) {\n\t\t\t\t// Rewind the cursor to the beginning of the buffer:\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._raiseWarning( 'INVALID_OPENING_QUOTE' )\n\t\t\t\t\t._rewind( idx )\n\t\t\t\t\t._changeState( QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\tparser._push( ch );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the delimiter character sequence:\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._rewind( delimiterLastIndex )._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:invalid_quote_end' );\n\n// Possible transition states...\nvar ERROR = state2enum[ 'error' ];\nvar FIELD = state2enum[ 'field' ];\nvar INIT = state2enum[ 'init' ];\n\n\n// FUNCTIONS //\n\n/**\n* Removes whitespace following a closing quote sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @param {NonNegativeInteger} state - next state\n* @returns {void}\n*/\nfunction removeWhitespace( parser, state ) {\n\t// Check whether the character sequence consists only of whitespace:\n\tif ( parser._isWhitespace( parser._qidx+1, parser._cursor ) ) {\n\t\t// Rewind the cursor and resume normal processing:\n\t\tparser._raiseWarning( 'INVALID_CLOSING_QUOTE' )\n\t\t\t._rewind( parser._cursor-parser._qidx )\n\t\t\t._changeState( state );\n\t\treturn;\n\t}\n\t// Non-whitespace characters came after a closing quote, leaving us in an ambiguous state: was the closing quote intended and we're missing a delimiter/newline, or was the closing quote a mistake and should have been escaped? We don't know, and so we must raise an exception:\n\tdebug( 'Error.' );\n\tparser._setErrorState( 'INVALID_CLOSING_QUOTE' )._changeState( ERROR );\n}\n\n\n// MAIN //\n\n/**\n* Returns a function for processing field characters after an ending quote sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar delimiter;\n\tvar newline;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the delimiter character sequence:\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._rewind( delimiterLastIndex );\n\n\t\t\t// Remove whitespace and resume processing:\n\t\t\tremoveWhitespace( parser, FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex );\n\n\t\t\t// Remove whitespace and resume processing:\n\t\t\tremoveWhitespace( parser, INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport maximum from './max.js';\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:quote_end' );\n\n// Possible transition states...\nvar ERROR = state2enum[ 'error' ];\nvar FIELD = state2enum[ 'field' ];\nvar INIT = state2enum[ 'init' ];\nvar INVALID_QUOTE_END = state2enum[ 'invalid_quote_end' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing an ending quote sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar quoteLastIndex;\n\tvar doublequote;\n\tvar delimiter;\n\tvar newline;\n\tvar strict;\n\tvar quote;\n\tvar max;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdoublequote = parser._doublequote;\n\tstrict = parser._strict;\n\n\tmax = maximum( maximum( delimiterLastIndex, newlineLastIndex ), quoteLastIndex ); // eslint-disable-line max-len\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a quote character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   When `doublequote` is `true`, quote character sequences are escaped by a preceding quote character sequence.\n\t\t* -   When `doublequote` is `false`, quote character sequences must be explicitly escaped using an escape character sequence.\n\t\t*/\n\t\tif (\n\t\t\tdoublequote &&\n\t\t\tch === quote[ quoteLastIndex ] &&\n\t\t\tparser._scan( quote, quoteLastIndex )\n\t\t) {\n\t\t\t// Keep the escaped quote character sequence and transition back to a quoted field state:\n\t\t\tdebug( 'Double quote.' );\n\t\t\tparser._push( ch )._changeState( QUOTED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the delimiter character sequence:\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._rewind( delimiterLastIndex )._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a non-special character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Field separators, row separators, and escaped quote sequences must immediately follow a potential closing quote sequence. At some point, we'll have processed a greater number of characters than exists in any of the special character sequences, meaning that none of those sequences immediately follow the quote sequence which led to the current state. Once this happens, we're in an invalid state and must raise an exception, as not clear how the parser should interpret the preceding values (e.g., was the preceding quote supposed to be escaped? was the preceding quote a mistake and should be ignored? are we missing a delimiter or newline sequence? etc.). In strict mode, we raise an exception. In non-strict mode, we only raise an exception if non-whitespace characters follow the potential closing quote sequence.\n\t\t*/\n\t\tif ( parser._cursor-parser._qidx >= max ) {\n\t\t\tif ( strict ) {\n\t\t\t\tdebug( 'Error.' );\n\t\t\t\tparser._setErrorState( 'INVALID_CLOSING_QUOTE' )._changeState( ERROR );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdebug( 'Invalid closing quote.' );\n\t\t\tparser._push( ch )._changeState( INVALID_QUOTE_END );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:quoted_escape' );\n\n// Possible transition states...\nvar ERROR = state2enum[ 'error' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing an escape sequence within a quoted field.\n*\n* ## Notes\n*\n* -   Within a quoted field, an escape sequence (only) escapes the quote sequence.\n* -   In strict mode, if not immediately followed by a special character sequence, then the parser raises an exception.\n* -   In non-strict mode, if not immediately followed by a special character sequence, then the escape sequence has no special meaning and is considered a normal character sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar escapeLength;\n\tvar strict;\n\tvar quote;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescapeLength = parser._escapeLength;\n\n\tstrict = parser._strict;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar cursor = parser._cursor;\n\t\tvar idx = parser._eidx; // position of last escape character\n\t\tvar d = cursor - idx;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a quote sequence.\n\t\t*/\n\t\tif (\n\t\t\td === quoteLastIndex &&\n\t\t\tch === quote[ quoteLastIndex ] &&\n\t\t\tparser._scan( quote, quoteLastIndex )\n\t\t) {\n\t\t\tdebug( 'Quote.' );\n\t\t\tparser._copyWithin( idx-escapeLastIndex, idx+1, quoteLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( QUOTED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a non-special character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In strict mode, quote sequences must immediately follow an escape sequence. At some point, we'll have processed a greater number of characters than exists in a quote sequence, meaning that a quote sequence does not immediately follow the escape sequence which led to the current state. Once this happens, we're in an invalid state and must raise an exception, as not clear how the parser should interpret the preceding values (e.g., was the preceding escape sequence a mistake and should be ignored? are we missing a quote sequence? etc.).\n\t\t* -   In non-strict mode, we assume that the escape sequence is a normal character sequence.\n\t\t*/\n\t\tif ( d >= quoteLastIndex ) {\n\t\t\tif ( strict ) {\n\t\t\t\tdebug( 'Error.' );\n\t\t\t\tparser._setErrorState( 'INVALID_QUOTED_ESCAPE' )._changeState( ERROR );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Return to normal field processing:\n\t\t\tdebug( 'Escape sequence is not followed by a quote sequence.' );\n\t\t\tparser._raiseWarning( 'INVALID_QUOTED_ESCAPE' )._push( ch )._changeState( QUOTED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:quoted_field' );\n\n// Possible transition states...\nvar QUOTE_END = state2enum[ 'quote_end' ];\nvar QUOTED_ESCAPE = state2enum[ 'quoted_escape' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a quoted field.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar doublequote;\n\tvar escape;\n\tvar quote;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdoublequote = parser._doublequote;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for an escape character sequence.\n\t\t*/\n\t\tif (\n\t\t\tdoublequote === false &&                // double quoting is disabled\n\t\t\tch === escape[ escapeLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( escape, escapeLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( QUOTED_ESCAPE );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for an ending quote character sequence.\n\t\t*/\n\t\tif (\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the quote character sequence:\n\t\t\tdebug( 'Quote.' );\n\t\t\tparser._rewind( quoteLastIndex )._changeState( QUOTE_END );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:skip' );\n\n// Possible transition states...\nvar INIT = state2enum[ 'init' ];\nvar SKIP = state2enum[ 'skip' ];\nvar SKIPPED_COMMENT = state2enum[ 'skipped_comment' ];\nvar SKIPPED_FIELD = state2enum[ 'skipped_field' ];\nvar SKIPPED_ESCAPE = state2enum[ 'skipped_escape' ];\nvar SKIPPED_QUOTED_FIELD = state2enum[ 'skipped_quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a skipped line.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar commentLastIndex;\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar skipLastIndex;\n\tvar delimiter;\n\tvar newline;\n\tvar comment;\n\tvar quoting;\n\tvar escape;\n\tvar strict;\n\tvar quote;\n\tvar skip;\n\n\tcommentLastIndex = parser._commentLastIndex;\n\tcomment = parser._comment;\n\n\tskipLastIndex = parser._skipLastIndex;\n\tskip = parser._skip;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tquoting = parser._quoting;\n\tstrict = parser._strict;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar idx = parser._cursor + 1;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for the start of a commented line.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In order for a row to be considered a commented line, the comment sequence must be the first character(s) of the field.\n\t\t*/\n\t\tif (\n\t\t\tcomment &&                                // user specified a comment character sequence, so should check for comments\n\t\t\tidx-commentLastIndex === 0 &&             // only search the first character(s) of the first field\n\t\t\tch === comment[ commentLastIndex ] &&     // we have a potential comment match\n\t\t\tparser._scan( comment, commentLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Comment.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_COMMENT );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for the start of a skipped line.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In order for a row to be considered a skipped line, the skip sequence must be the first character(s) of the field.\n\t\t*/\n\t\tif (\n\t\t\tskip &&                                // user specified a skip character sequence, so should check for skipped lines\n\t\t\tidx-skipLastIndex === 0 &&             // only search the first character(s) of the first field\n\t\t\tch === skip[ skipLastIndex ] &&        // we have a potential match\n\t\t\tparser._scan( skip, skipLastIndex )    // we found a match\n\t\t) {\n\t\t\tdebug( 'Skip.' );\n\t\t\tparser._push( ch )._changeState( SKIP );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for an escape character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   An escape sequence escapes the delimiter, newline, and escape sequences in **non-quoted** fields.\n\t\t* -   An escape sequence escapes comment and skip sequences in **non-quoted** fields when an escape sequence occurs at the beginning of a record.\n\t\t* -   When `doublequote` is `false`, the escape sequence escapes quote sequences within **quoted** fields.\n\t\t* -   If not immediately followed by a special character sequence, then the escape sequence has no special meaning.\n\t\t*/\n\t\tif (\n\t\t\tch === escape[ escapeLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( escape, escapeLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_ESCAPE );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a quote character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tidx-quoteLastIndex === 0 &&           // only search the first character(s) of the field\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tif ( quoting ) {\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._push( ch )._changeState( SKIPPED_QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\tparser._push( ch );\n\t\t\treturn;\n\t\t}\n\t\t/**\n\t\t* Check for a quote character sequence (non-strict mode).\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In non-strict mode, a quote character sequence is allowed to start after whitespace (e.g., `a,  \"b\",  c`).\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tstrict === false &&                   // non-strict mode\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tif ( quoting && parser._isWhitespace( 0, parser._cursor-quoteLastIndex ) ) {\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._push( ch )._changeState( SKIPPED_QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\tparser._push( ch );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:skipped_comment' );\n\n// Possible transition states...\nvar INIT = state2enum[ 'init' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a skipped commented line.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar newlineLastIndex;\n\tvar newline;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t// Check for the end of the commented line...\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport maximum from './max.js';\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:skipped_escape' );\n\n// Possible transition states...\nvar SKIPPED_FIELD = state2enum[ 'skipped_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing an escape sequence within a skipped line.\n*\n* ## Notes\n*\n* -   An escape sequence escapes the delimiter, newline, and escape sequences in **non-quoted** fields.\n* -   An escape sequence escapes comment and skip sequences in **non-quoted** fields when an escape sequence occurs at the beginning of a record.\n* -   If not immediately followed by a special character sequence, then the escape sequence has no special meaning and is considered a normal character sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar commentLastIndex;\n\tvar escapeLastIndex;\n\tvar skipLastIndex;\n\tvar delimiter;\n\tvar newline;\n\tvar comment;\n\tvar escape;\n\tvar skip;\n\tvar max;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tcommentLastIndex = parser._commentLastIndex;\n\tcomment = parser._comment;\n\n\tskipLastIndex = parser._skipLastIndex;\n\tskip = parser._skip;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tmax = maximum( maximum( delimiterLastIndex, newlineLastIndex ), escapeLastIndex ); // eslint-disable-line max-len\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar cursor = parser._cursor;\n\t\tvar idx = parser._eidx; // position of last escape character\n\t\tvar d = cursor - idx;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\td === delimiterLastIndex &&\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\td === newlineLastIndex &&\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for an escape sequence.\n\t\t*/\n\t\tif (\n\t\t\td === escapeLastIndex &&\n\t\t\tch === escape[ escapeLastIndex ] &&\n\t\t\tparser._scan( escape, escapeLastIndex )\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a comment sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Comment sequences only have special meaning when appearing at the beginning of a row.\n\t\t*/\n\t\tif (\n\t\t\tcomment &&                                 // user specified a comment character sequence, so should check for comments\n\t\t\tcursor-commentLastIndex === 0 &&           // only search the first character(s) of the row\n\t\t\tch === comment[ commentLastIndex ] &&      // we have a potential match\n\t\t\tparser._scan( comment, commentLastIndex )  // we found a match\n\t\t) {\n\t\t\tdebug( 'Comment.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a skip sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Skip sequences only have special meaning when appearing at the beginning of a row.\n\t\t*/\n\t\tif (\n\t\t\tskip &&                                 // user specified a skip character sequence, so should check for a skipped line\n\t\t\tcursor-skipLastIndex === 0 &&           // only search the first character(s) of the row\n\t\t\tch === skip[ skipLastIndex ] &&         // we have a potential match\n\t\t\tparser._scan( skip, skipLastIndex )     // we found a match\n\t\t) {\n\t\t\tdebug( 'Skip.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a non-special character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Field separators, row separators, and escaped sequences must immediately follow an escape sequence. At some point, we'll have processed a greater number of characters than exists in any of the special character sequences, meaning that none of those sequences immediately follow the escape sequence which led to the current state. Once this happens, we assume that the escape sequence is a normal character sequence.\n\t\t*/\n\t\tif ( d >= max ) {\n\t\t\tdebug( 'Normal character sequence.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:skipped_field' );\n\n// Possible transition states...\nvar INIT = state2enum[ 'init' ];\nvar SKIPPED_ESCAPE = state2enum[ 'skipped_escape' ];\nvar SKIPPED_FIELD = state2enum[ 'skipped_field' ];\nvar SKIPPED_QUOTED_FIELD = state2enum[ 'skipped_quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a field within a skipped line.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar delimiter;\n\tvar newline;\n\tvar quoting;\n\tvar escape;\n\tvar strict;\n\tvar quote;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tquoting = parser._quoting;\n\tstrict = parser._strict;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar idx = parser._cursor - parser._cidx + 1;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for an escape character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   An escape sequence escapes the delimiter, newline, and escape sequences in **non-quoted** fields.\n\t\t* -   When `doublequote` is `false`, the escape sequence escapes quote sequences within **quoted** fields.\n\t\t* -   If not immediately followed by a special character sequence, then the escape sequence has no special meaning.\n\t\t*/\n\t\tif (\n\t\t\tch === escape[ escapeLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( escape, escapeLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_ESCAPE );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a quote character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tidx-quoteLastIndex === 0 &&           // only search the first character(s) of the field\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tparser._push( ch );\n\t\t\tif ( quoting ) {\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._changeState( SKIPPED_QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\treturn;\n\t\t}\n\t\t/**\n\t\t* Check for a quote character sequence (non-strict mode).\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In non-strict mode, a quote character sequence is allowed to start after whitespace (e.g., `a,  \"b\",  c`).\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tstrict === false &&                   // non-strict mode\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tparser._push( ch );\n\t\t\tif ( quoting && parser._isWhitespace( parser._cidx, parser._cursor-quoteLastIndex ) ) {\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._changeState( SKIPPED_QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:skipped_invalid_quote_end' );\n\n// Possible transition states...\nvar SKIPPED_FIELD = state2enum[ 'skipped_field' ];\nvar INIT = state2enum[ 'init' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing field characters after an ending quote sequence within a skipped line.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar delimiter;\n\tvar newline;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport maximum from './max.js';\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:skipped_quote_end' );\n\n// Possible transition states...\nvar INIT = state2enum[ 'init' ];\nvar SKIPPED_FIELD = state2enum[ 'skipped_field' ];\nvar SKIPPED_INVALID_QUOTE_END = state2enum[ 'skipped_invalid_quote_end' ];\nvar SKIPPED_QUOTED_FIELD = state2enum[ 'skipped_quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing an ending quote sequence within a skipped line.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar quoteLastIndex;\n\tvar doublequote;\n\tvar delimiter;\n\tvar newline;\n\tvar quote;\n\tvar max;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdoublequote = parser._doublequote;\n\n\tmax = maximum( maximum( delimiterLastIndex, newlineLastIndex ), quoteLastIndex ); // eslint-disable-line max-len\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a quote character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   When `doublequote` is `true`, quote character sequences are escaped by a preceding quote character sequence.\n\t\t* -   When `doublequote` is `false`, quote character sequences must be explicitly escaped using an escape character sequence.\n\t\t*/\n\t\tif (\n\t\t\tdoublequote &&\n\t\t\tch === quote[ quoteLastIndex ] &&\n\t\t\tparser._scan( quote, quoteLastIndex )\n\t\t) {\n\t\t\tdebug( 'Double quote.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_QUOTED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a non-special character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Field separators, row separators, and escaped quote sequences must immediately follow a potential closing quote sequence. At some point, we'll have processed a greater number of characters than exists in any of the special character sequences, meaning that none of those sequences immediately follow the quote sequence which led to the current state. Once this happens, we in an invalid state.\n\t\t*/\n\t\tif ( parser._cursor-parser._qidx >= max ) {\n\t\t\tdebug( 'Invalid closing quote.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_INVALID_QUOTE_END );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:skipped_quoted_escape' );\n\n// Possible transition states...\nvar SKIPPED_QUOTED_FIELD = state2enum[ 'skipped_quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing an escape sequence within a quoted field within a skipped line.\n*\n* ## Notes\n*\n* -   Within a quoted field, an escape sequence (only) escapes the quote sequence.\n* -   If not immediately followed by a special character sequence, then the escape sequence has no special meaning and is considered a normal character sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar quoteLastIndex;\n\tvar quote;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar cursor = parser._cursor;\n\t\tvar idx = parser._eidx; // position of last escape character\n\t\tvar d = cursor - idx;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a quote sequence.\n\t\t*/\n\t\tif (\n\t\t\td === quoteLastIndex &&\n\t\t\tch === quote[ quoteLastIndex ] &&\n\t\t\tparser._scan( quote, quoteLastIndex )\n\t\t) {\n\t\t\tdebug( 'Quote.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_QUOTED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a non-special character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Quote sequences must immediately follow an escape sequence. At some point, we'll have processed a greater number of characters than exists in a quote sequence, meaning that a quote sequence does not immediately follow the escape sequence which led to the current state. Once this happens, we assume that the escape sequence is a normal character sequence.\n\t\t*/\n\t\tif ( d >= quoteLastIndex ) {\n\t\t\t// Return to normal field processing:\n\t\t\tdebug( 'Escape sequence is not followed by a quote sequence.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_QUOTED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport state2enum from './state2enum.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:skipped_quoted_field' );\n\n// Possible transition states...\nvar SKIPPED_QUOTE_END = state2enum[ 'skipped_quote_end' ];\nvar SKIPPED_QUOTED_ESCAPE = state2enum[ 'skipped_quoted_escape' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a quoted field within a skipped line.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar doublequote;\n\tvar escape;\n\tvar quote;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdoublequote = parser._doublequote;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for an escape character sequence.\n\t\t*/\n\t\tif (\n\t\t\tdoublequote === false &&                // double quoting is disabled\n\t\t\tch === escape[ escapeLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( escape, escapeLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_QUOTED_ESCAPE );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for an ending quote character sequence.\n\t\t*/\n\t\tif (\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Quote.' );\n\t\t\tparser._push( ch )._changeState( SKIPPED_QUOTE_END );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport enum2state from './enum2state.json';\nimport closed from './closed.js'; // eslint-disable-line stdlib/no-redeclare\nimport comment from './comment.js';\nimport error from './error.js';\nimport escape from './escape.js'; // eslint-disable-line stdlib/no-redeclare\nimport field from './field.js';\nimport init from './init.js';\nimport invalidQuoteEnd from './invalid_quote_end.js';\nimport quoteEnd from './quote_end.js';\nimport quotedEscape from './quoted_escape.js';\nimport quotedField from './quoted_field.js';\nimport skip from './skip.js';\nimport skippedComment from './skipped_comment.js';\nimport skippedEscape from './skipped_escape.js';\nimport skippedField from './skipped_field.js';\nimport skippedInvalidQuoteEnd from './skipped_invalid_quote_end.js';\nimport skippedQuoteEnd from './skipped_quote_end.js';\nimport skippedQuotedEscape from './skipped_quoted_escape.js';\nimport skippedQuotedField from './skipped_quoted_field.js';\n\n\n// VARIABLES //\n\nvar table = {\n\t'closed': closed,\n\t'comment': comment,\n\t'escape': escape,\n\t'error': error,\n\t'field': field,\n\t'init': init,\n\t'invalid_quote_end': invalidQuoteEnd,\n\t'quote_end': quoteEnd,\n\t'quoted_escape': quotedEscape,\n\t'quoted_field': quotedField,\n\t'skip': skip,\n\t'skipped_comment': skippedComment,\n\t'skipped_escape': skippedEscape,\n\t'skipped_field': skippedField,\n\t'skipped_invalid_quote_end': skippedInvalidQuoteEnd,\n\t'skipped_quote_end': skippedQuoteEnd,\n\t'skipped_quoted_escape': skippedQuotedEscape,\n\t'skipped_quoted_field': skippedQuotedField\n};\n\n\n// MAIN //\n\n/**\n* Returns an object mapping state enumeration constants to state functions.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Array<Function>} table\n*/\nfunction states( parser ) {\n\tvar out;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < enum2state.length; i++ ) {\n\t\tout.push( table[ enum2state[ i ] ]( parser ) );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default states;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this, max-len, no-underscore-dangle, max-lines */\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport setReadOnlyAccessor from '@stdlib/utils-define-nonenumerable-read-only-accessor';\nimport Boolean from '@stdlib/boolean-ctor';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport rescape from '@stdlib/utils-escape-regexp-string';\nimport replace from '@stdlib/string-base-replace';\nimport defaults from './defaults.js';\nimport state2enum from './states/state2enum.js';\nimport enum2state from './states/enum2state.json';\nimport states from './states';\n\n\n// VARIABLES //\n\nvar debug = logger( 'parser' );\n\n// Parser states:\nvar CLOSED = state2enum[ 'closed' ];\nvar COMMENT = state2enum[ 'comment' ];\nvar ERROR = state2enum[ 'error' ];\nvar ESCAPE = state2enum[ 'escape' ];\nvar FIELD = state2enum[ 'field' ];\nvar INIT = state2enum[ 'init' ];\nvar INVALID_QUOTE_END = state2enum[ 'invalid_quote_end' ];\nvar QUOTE_END = state2enum[ 'quote_end' ];\nvar QUOTED_ESCAPE = state2enum[ 'quoted_escape' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\nvar SKIP = state2enum[ 'skip' ];\nvar SKIPPED_COMMENT = state2enum[ 'skipped_comment' ];\nvar SKIPPED_ESCAPE = state2enum[ 'skipped_escape' ];\nvar SKIPPED_FIELD = state2enum[ 'skipped_field' ];\nvar SKIPPED_INVALID_QUOTE_END = state2enum[ 'skipped_invalid_quote_end' ];\nvar SKIPPED_QUOTE_END = state2enum[ 'skipped_quote_end' ];\nvar SKIPPED_QUOTED_ESCAPE = state2enum[ 'skipped_quoted_escape' ];\nvar SKIPPED_QUOTED_FIELD = state2enum[ 'skipped_quoted_field' ];\n\n\n// FUNCTIONS //\n\n/**\n* Returns a regular expression pattern which matches a list of strings.\n*\n* @private\n* @param {StringArray} list - list of strings to match\n* @returns {string} regular expression pattern\n*/\nfunction array2pattern( list ) {\n\tvar pattern;\n\tvar i;\n\n\tpattern = '(?:';\n\tfor ( i = 0; i < list.length-1; i++ ) {\n\t\tpattern += rescape( list[ i ] ) + '|';\n\t}\n\treturn pattern + rescape( list[ i ] ) + ')';\n}\n\n\n// MAIN //\n\n/**\n* Returns an incremental parser for delimiter-separated values.\n*\n* @constructor\n* @param {Options} options - options object\n* @returns {Parser} parser instance\n*\n* @example\n* var parser = new Parser();\n*\n* // ...\n*\n* parser.next( '1,2,3,4\\n' );\n*\n* // ...\n*\n* parser.next( '5,6,7,8\\n' );\n*\n* // ...\n*\n* parser.next( '9,10,11,12\\n' );\n*\n* // ...\n*\n* parser.close();\n*\n* // ...\n*\n* var bool = parser.done;\n* // returns true\n*/\nfunction Parser( options ) {\n\tvar opts;\n\n\tif ( !( this instanceof Parser ) ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn new Parser( options );\n\t\t}\n\t\treturn new Parser();\n\t}\n\t// TODO: option validation; enforce quote, comment, skip, delimiter, escape, and newline all being different and none can be a substring of the other (i.e., no escape equal to `,,` and delimiter equal to `,`, and no delimiter equal to `,` and newline being `,,` and vice versa; is `,,` an escape or simply an empty field?); should probably require that \"whitespace\" does not conflict with any of the special character sequences; require at least one whitespace character\n\toptions = options || {};\n\topts = defaults();\n\n\t// Buffer for tracking internal state:\n\tthis._buffer = [];\n\n\t// Index of the most recently processed character:\n\tthis._cursor = -1;\n\n\t// Index marking the beginning of the current field:\n\tthis._cidx = 0;\n\n\t// Indices marking the most recent unescaped quote sequence:\n\tthis._qidx = -1;\n\n\t// Indices marking the most recent escape sequence:\n\tthis._eidx = -1;\n\n\t// Buffer for storing the field values for the current row:\n\tthis._rowBufferFLG = Boolean( options.rowBuffer );\n\tthis._rowBuffer = options.rowBuffer || opts.rowBuffer;\n\n\t// Column, row, and line counters:\n\tthis._col = 0;\n\tthis._row = 0;\n\tthis._line = 0;\n\n\t// Initialize flags indicating whether we're processing a commented/skipped line:\n\tthis._commented = false;\n\tthis._skipped = false;\n\n\t// Initialize the error state:\n\tthis._errname = '';\n\n\t// Extract various options:\n\tthis._comment = options.comment || opts.comment;\n\tthis._delimiter = options.delimiter || opts.delimiter;\n\tthis._doublequote = ( options.doublequote === void 0 ) ? opts.doublequote : options.doublequote;\n\tthis._escape = options.escape || opts.escape;\n\tthis._ltrim = ( options.ltrim === void 0 ) ? opts.ltrim : options.ltrim;\n\tthis._maxRows = ( options.maxRows === void 0 ) ? opts.maxRows : options.maxRows;\n\tthis._newline = options.newline || opts.newline;\n\tthis._quote = options.quote || opts.quote;\n\tthis._quoting = ( options.quoting === void 0 ) ? opts.quoting : options.quoting;\n\tthis._rtrim = ( options.rtrim === void 0 ) ? opts.rtrim : options.rtrim;\n\tthis._skip = options.skip || opts.skip;\n\tthis._skipBlankRows = ( options.skipBlankRows === void 0 ) ? opts.skipBlankRows : options.skipBlankRows;\n\tthis._skipRow = options.skipRow || opts.skipRow;\n\tthis._strict = ( options.strict === void 0 ) ? opts.strict : options.strict;\n\tthis._trimComment = ( options.trimComment === void 0 ) ? opts.trimComment : options.trimComment;\n\tthis._whitespace = array2pattern( options.whitespace || opts.whitespace );\n\n\tthis._reWhitespace = new RegExp( '^'+this._whitespace+'*([\\\\S\\\\s]*?)'+this._whitespace+'*$' );\n\tthis._reWhitespaceLeft = new RegExp( '^'+this._whitespace+'*' );\n\tthis._reWhitespaceRight = new RegExp( this._whitespace+'*$' );\n\n\tthis._onClose = options.onClose || opts.onClose;\n\tthis._onColumn = options.onColumn || opts.onColumn;\n\tthis._onComment = options.onComment || opts.onComment;\n\tthis._onRow = options.onRow || opts.onRow;\n\tthis._onSkip = options.onSkip || opts.onSkip;\n\n\tthis._onError = options.onError || opts.onError;\n\tthis._onWarn = options.onWarn || opts.onWarn;\n\n\tthis._commentLength = this._comment.length;\n\tthis._commentLastIndex = this._commentLength - 1;\n\n\tthis._delimiterLength = this._delimiter.length;\n\tthis._delimiterLastIndex = this._delimiterLength - 1;\n\n\tthis._escapeLength = this._escape.length;\n\tthis._escapeLastIndex = this._escapeLength - 1;\n\n\tthis._newlineLength = this._newline.length;\n\tthis._newlineLastIndex = this._newlineLength - 1;\n\n\tthis._quoteLength = this._quote.length;\n\tthis._quoteLastIndex = this._quoteLength - 1;\n\n\tthis._skipLength = this._skip.length;\n\tthis._skipLastIndex = this._skipLength - 1;\n\n\t// Initialize the state flag:\n\tif ( this._skipRow && this._skipRow( 0, 0 ) ) {\n\t\tthis._state = SKIP;\n\t\tthis._skipped = true;\n\t} else {\n\t\tthis._state = INIT;\n\t}\n\t// Initialize state processors...\n\tthis._states = states( this ); // NOTE: this should come after all other initialization!\n\n\treturn this;\n}\n\n/**\n* Updates state by adding a processed character to an internal buffer.\n*\n* @private\n* @name _push\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} ch - character\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_push', function push( ch ) {\n\tvar buf = this._buffer;\n\n\t// Increment the internal buffer pointer:\n\tthis._cursor += 1;\n\n\t// Only expand the internal buffer if we've run out of previously allocated memory...\n\tif ( this._cursor >= buf.length ) {\n\t\tbuf.push( ch );\n\t\tdebug( 'Internal buffer size increased. Length: %d.', buf.length );\n\t} else {\n\t\t// Reuse existing memory:\n\t\tbuf[ this._cursor ] = ch;\n\t}\n\tdebug( 'Cursor: %d. Push: %s', this._cursor, ch );\n\treturn this;\n});\n\n/**\n* Rewinds the internal buffer cursor by a specified amount.\n*\n* @private\n* @name _rewind\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} N - number of elements to rewind\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_rewind', function rewind( N ) {\n\tthis._cursor -= N;\n\n\tdebug( 'Rewind: %d. Cursor: %d.', N, this._cursor );\n\treturn this;\n});\n\n/**\n* Copies a sequence of internal buffer elements to an earlier position in the buffer.\n*\n* @private\n* @name _copyWithin\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} target - starting position to which to copy elements\n* @param {NonNegativeInteger} start - staring index of the elements to copy (inclusive)\n* @param {NonNegativeInteger} N - number of elements to copy\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_copyWithin', function copyWithin( target, start, N ) {\n\tvar buf;\n\tvar i;\n\n\tbuf = this._buffer;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tbuf[ target+i ] = buf[ start+i ];\n\t}\n\treturn this;\n});\n\n/**\n* Returns the contents of a buffer slice.\n*\n* @private\n* @name _slice\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} start - starting character index (inclusive)\n* @param {NonNegativeInteger} end - ending character index (inclusive)\n* @returns {string} buffer contents\n*/\nsetReadOnly( Parser.prototype, '_slice', function slice( start, end ) {\n\treturn this._buffer.slice( start, end+1 ).join( '' );\n});\n\n/**\n* Checks whether the contents of a buffer slice consists of only whitespace.\n*\n* @private\n* @name _isWhitespace\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} start - starting character index (inclusive)\n* @param {NonNegativeInteger} end - ending character index (inclusive)\n* @returns {boolean} boolean indicating whether a buffer slice consists of only whitespace\n*/\nsetReadOnly( Parser.prototype, '_isWhitespace', function isWhitespace( start, end ) {\n\treturn ( replace( this._slice( start, end ), this._reWhitespaceLeft, '' ) === '' );\n});\n\n/**\n* Resets the parser.\n*\n* @private\n* @name _reset\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_reset', function reset() {\n\t// Reset counters and indices:\n\tthis._col = 0;\n\tthis._cidx = 0;\n\tthis._qidx = -1;\n\tthis._eidx = -1;\n\n\t// Reset the parser state...\n\tif ( this._skipRow && this._skipRow( this._row, this._line ) ) {\n\t\tthis._state = SKIP;\n\t\tthis._skipped = true;\n\t} else {\n\t\tthis._state = INIT;\n\t\tthis._skipped = false;\n\t}\n\tthis._commented = false;\n\n\t// Reset the buffer:\n\tthis._cursor = -1;\n\n\tdebug( 'Parser reset.' );\n\treturn this;\n});\n\n/**\n* Sets a field value in an internal row buffer.\n*\n* @private\n* @name _set\n* @memberof Parser.prototype\n* @type {Function}\n* @param {*} value - field value\n* @param {NonNegativeInteger} idx - field index\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_setField', function set( value, idx ) {\n\tvar buf = this._rowBuffer;\n\n\t// FIXME: as buffer may be provided from userland, use `set` accessor and consider using `@stdlib/utils/push` to allow support of dynamically resizing fixed length buffers\n\n\t// Only expand the row buffer if we've run out of previously allocated memory...\n\tif ( idx >= buf.length ) {\n\t\tbuf.push( value );\n\t\tdebug( 'Row buffer size increased. Length: %d.', buf.length );\n\t} else {\n\t\t// Reuse existing memory:\n\t\tbuf[ idx ] = value;\n\t}\n\treturn this;\n});\n\n/**\n* Returns a field value.\n*\n* @private\n* @name _getField\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} start - starting character index (inclusive)\n* @param {NonNegativeInteger} end - ending character index (inclusive)\n* @returns {string} field value\n*/\nsetReadOnly( Parser.prototype, '_getField', function get( start, end ) {\n\tvar v = this._slice( start, end );\n\tif ( this._ltrim ) {\n\t\tif ( this._rtrim ) {\n\t\t\treturn replace( v, this._reWhitespace, '$1' );\n\t\t}\n\t\treturn replace( v, this._reWhitespaceLeft, '' );\n\t}\n\tif ( this._rtrim ) {\n\t\treturn replace( v, this._reWhitespaceRight, '' );\n\t}\n\treturn v;\n});\n\n/**\n* Returns the current row of values.\n*\n* @private\n* @name _getRow\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {ArrayLikeObject} row of values\n*/\nsetReadOnly( Parser.prototype, '_getRow', function get() {\n\tif ( this._rowBufferFLG ) {\n\t\treturn this._rowBuffer;\n\t}\n\t// Return a shallow copy to avoid mutating internal state:\n\treturn this._rowBuffer.slice( 0, this._col );\n});\n\n/**\n* Scans the internal buffer for a specified character sequence.\n*\n* ## Notes\n*\n* -   Given an internal buffer\n*\n*     ```text\n*     | ... | a | b |\n*     ```\n*\n*     search character sequence\n*\n*     ```text\n*     | a | b | c |\n*     ```\n*\n*     and `N` equal to `2`, the method will begin scanning from the position of `a` in the internal buffer above and compare to each element of the first `N` characters of the search character sequence.\n*\n*     This method is intended to be used in scenarios where we already know that an incoming character matches the last character of the search sequence, and we want to know whether the rest of the search sequence matches the most recently added elements in the internal buffer.\n*\n* @private\n* @name _scan\n* @memberof Parser.prototype\n* @type {Function}\n* @param {StringArray} search - character sequence\n* @param {NonNegativeInteger} N - number of characters to search\n* @returns {boolean} boolean indicating whether a match was found\n*/\nsetReadOnly( Parser.prototype, '_scan', function scan( search, N ) {\n\tvar buf;\n\tvar idx;\n\tvar i;\n\n\tbuf = this._buffer;\n\tidx = this._cursor - N + 1;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( buf[ idx+i ] !== search[ i ] ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ( i === N );\n});\n\n/**\n* Processes a field.\n*\n* @private\n* @name _onField\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onField', function onField() {\n\t// Extract the field value:\n\tvar v = this._getField( this._cidx, this._cursor );\n\n\t// Insert the field value into the row buffer:\n\tthis._setField( v, this._col );\n\n\t// Invoke a callback for receiving field values:\n\tthis._onColumn( v, this._row, this._col, this._line );\n\tdebug( 'Field. Line: %d. Row: %d. Column: %d. Value: %s', this._line, this._row, this._col, v );\n\n\t// Increment the field counter to record that we've moved on to the next field:\n\tthis._col += 1;\n\n\t// Increment the index marking the beginning of the next field:\n\tthis._cidx = this._cursor + 1; // +1 as the cursor currently points to the last character in the current field, and, thus, the next field should start at the next index\n\n\t// Reset indices:\n\tthis._qidx = -1;\n\tthis._eidx = -1;\n\n\treturn this;\n});\n\n/**\n* Processes a record.\n*\n* @private\n* @name _onRecord\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onRecord', function onRecord() {\n\tvar v;\n\n\t// Extract the field value:\n\tv = this._getField( this._cidx, this._cursor );\n\n\t// Check for a blank row (i.e., a row consisting only of whitespace):\n\tif ( this._skipBlankRows && this._col === 0 ) {\n\t\tif ( v === '' || replace( v, this._reWhitespaceLeft, '' ) === '' ) {\n\t\t\treturn this._onSkippedRow();\n\t\t}\n\t}\n\t// Insert the field value into the row buffer:\n\tthis._setField( v, this._col );\n\n\t// Invoke a callback for receiving field values:\n\tthis._onColumn( v, this._row, this._col, this._line );\n\tthis._col += 1;\n\n\t// Invoke a callback for receiving rows:\n\tthis._onRow( this._getRow(), this._row, this._col, this._line );\n\tdebug( 'Record. Line: %d. Fields: %d.', this._line, this._col );\n\n\t// Increment row and line counters to indicate that we've moved on to the next row/line:\n\tthis._row += 1;\n\tthis._line += 1;\n\n\t// Reset the parser:\n\tthis._reset();\n\n\t// Check whether we have processed a desired number of rows...\n\tif ( this._row >= this._maxRows ) {\n\t\tthis._changeState( CLOSED );\n\t}\n\treturn this;\n});\n\n/**\n* Processes a commented row.\n*\n* @private\n* @name _onCommentedRow\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onCommentedRow', function onCommentedRow() {\n\tvar v;\n\n\t// Invoke a callback for receiving commented lines:\n\tif ( this._onComment ) {\n\t\tv = this._slice( 0, this._cursor );\n\t\tif ( this._trimComment ) {\n\t\t\tv = replace( v, this._reWhitespaceLeft, '' );\n\t\t}\n\t\tthis._onComment( v, this._line );\n\t\tdebug( 'Comment. Line: %d. Value: %s', this._line, v );\n\t} else {\n\t\tdebug( 'Comment. Line: %d.', this._line );\n\t}\n\t// Increment the counter for how many lines have been processed:\n\tthis._line += 1;\n\n\t// Reset the parser:\n\tthis._reset();\n\n\treturn this;\n});\n\n/**\n* Processes a skipped row.\n*\n* @private\n* @name _onSkippedRow\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onSkippedRow', function onSkippedRow() {\n\tvar v;\n\n\t// Invoke a callback for receiving skipped lines:\n\tif ( this._onSkip ) {\n\t\tv = this._slice( 0, this._cursor );\n\t\tthis._onSkip( v, this._line );\n\t\tdebug( 'Skipped row. Line: %d. Value: %s', this._line, v );\n\t} else {\n\t\tdebug( 'Skipped row. Line: %d.', this._line );\n\t}\n\t// Increment the counter for how many lines have been processed:\n\tthis._line += 1;\n\n\t// Reset the parser:\n\tthis._reset();\n\n\treturn this;\n});\n\n/**\n* Processes a closing quote sequence.\n*\n* @private\n* @name _onClosingQuote\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onClosingQuote', function onClosingQuote() {\n\t// Cache the cursor position marking the end of the closing quote sequence:\n\tthis._qidx = this._cursor;\n\treturn this;\n});\n\n/**\n* Processes an escape sequence.\n*\n* @private\n* @name _onEscape\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onEscape', function onEscape() {\n\t// Cache the cursor position marking the end of the escape sequence:\n\tthis._eidx = this._cursor;\n\treturn this;\n});\n\n/**\n* Creates a parser exception.\n*\n* @private\n* @name _createException\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} name - exception name\n* @returns {Error} parser exception\n*/\nsetReadOnly( Parser.prototype, '_createException', function createException( name ) {\n\tvar err;\n\n\tswitch ( name ) {\n\tcase 'INVALID_CLOSING_QUOTE':\n\t\terr = new Error( format( '1hHET', this._col, this._line ) );\n\t\tbreak;\n\tcase 'INVALID_OPENING_QUOTE':\n\t\terr = new Error( format( '1hHEU', this._col, this._line ) );\n\t\tbreak;\n\tcase 'INVALID_ESCAPE':\n\t\terr = new Error( format( '1hHEV', this._col, this._line ) );\n\t\tbreak;\n\tcase 'INVALID_QUOTED_ESCAPE':\n\t\terr = new Error( format( '1hHEW', this._col, this._line ) );\n\t\tbreak;\n\tcase 'CLOSED':\n\t\terr = new Error( format('1hHD6') );\n\t\tbreak;\n\tdefault:\n\t\terr = new Error( format('1hHD7') );\n\t\tbreak;\n\t}\n\treturn err;\n});\n\n/**\n* Raises a parser warning.\n*\n* @private\n* @name _raiseWarning\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} name - exception name\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_raiseWarning', function raiseWarning( name ) {\n\tvar err;\n\n\tif ( this._onWarn ) {\n\t\terr = this._createException( name );\n\n\t\tdebug( 'Warning: %s', err.message );\n\t\tthis._onWarn( err );\n\t}\n\treturn this;\n});\n\n/**\n* Raises a parser exception.\n*\n* @private\n* @name _raiseException\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_raiseException', function raiseException() {\n\tvar err = this._createException( this._errname );\n\n\tdebug( 'Error: %s', err.message );\n\tthis._onError( err );\n\n\treturn this;\n});\n\n/**\n* Updates the parser state.\n*\n* @private\n* @name _changeState\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} state - state enumeration constant\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_changeState', function changeState( state ) {\n\tdebug( 'State transition: %s -> %s.', enum2state[ this._state ], enum2state[ state ] );\n\n\tswitch ( state ) { // eslint-disable-line default-case\n\tcase CLOSED:\n\t\tthis._close();\n\t\tbreak;\n\tcase COMMENT:\n\t\tthis._commented = true;\n\t\tbreak;\n\tcase ERROR:\n\t\tthis._raiseException();\n\t\tbreak;\n\tcase ESCAPE:\n\t\tthis._onEscape();\n\t\tbreak;\n\tcase FIELD:\n\t\tif ( this._state !== ESCAPE ) {\n\t\t\tthis._onField();\n\t\t}\n\t\tbreak;\n\tcase INIT:\n\t\tif ( this._commented ) {\n\t\t\tthis._onCommentedRow();\n\t\t} else if ( this._skipped ) {\n\t\t\tthis._onSkippedRow();\n\t\t} else {\n\t\t\tthis._onRecord();\n\t\t}\n\t\tbreak;\n\tcase INVALID_QUOTE_END:\n\t\tbreak;\n\tcase QUOTE_END:\n\t\tthis._onClosingQuote();\n\t\tbreak;\n\tcase QUOTED_ESCAPE:\n\t\tthis._onEscape();\n\t\tbreak;\n\tcase QUOTED_FIELD:\n\t\tbreak;\n\tcase SKIP:\n\t\tthis._skipped = true;\n\t\tbreak;\n\tcase SKIPPED_COMMENT:\n\tcase SKIPPED_ESCAPE:\n\tcase SKIPPED_FIELD:\n\tcase SKIPPED_INVALID_QUOTE_END:\n\tcase SKIPPED_QUOTE_END:\n\tcase SKIPPED_QUOTED_ESCAPE:\n\tcase SKIPPED_QUOTED_FIELD:\n\t\tbreak;\n\t}\n\tthis._state = state;\n\treturn this;\n});\n\n/**\n* Sets the parser's error state.\n*\n* @private\n* @name _setErrorState\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} name - error name\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_setErrorState', function setErrorState( name ) {\n\tif ( name ) {\n\t\tdebug( 'Error: %s.', name );\n\t} else {\n\t\tdebug( 'Reset error state.' );\n\t}\n\tthis._errname = name;\n\treturn this;\n});\n\n/**\n* Closes the parser.\n*\n* @private\n* @name _close\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_close', function close() {\n\tvar state;\n\tvar v;\n\n\tif ( this.done ) {\n\t\tthis._setErrorState( CLOSED )._changeState( ERROR );\n\t\treturn this;\n\t}\n\tif ( this._cursor >= 0 ) {\n\t\tstate = this._state;\n\t\tif ( state === INIT || state === FIELD || state === QUOTE_END ) {\n\t\t\t// If the current state is \"field\" or \"quote end\", we're in a valid state and can simply transition to our initial state to indicate that we've processed a record:\n\t\t\tthis._changeState( INIT )._onClose();\n\t\t} else {\n\t\t\t// Check if we were able to process part of a row...\n\t\t\tif ( this._col ) {\n\t\t\t\t// This may be an incomplete row!!!\n\t\t\t\tthis._onRow( this._getRow(), this._row, this._col );\n\t\t\t}\n\t\t\t// Extract however much of the current field we were able to process:\n\t\t\tv = this._slice( this._cidx, this._cursor );\n\n\t\t\t// Return the unfinished field to the client (although this may not be equal to the original character sequence, as escape sequences may have already been stripped!):\n\t\t\tdebug( 'Flush: %s', v );\n\t\t\tthis._onClose( v );\n\t\t}\n\t} else {\n\t\tthis._onClose();\n\t}\n\tdebug( 'Closed.' );\n\treturn this;\n});\n\n/**\n* Parses the next chunk.\n*\n* @name next\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} chunk - chunk\n* @throws {Error} unable to parse new chunks\n* @throws {Error} invalid field\n* @throws {Error} invalid record\n* @returns {Parser} parser instance\n*\n* @example\n* var parser = new Parser();\n*\n* // ...\n*\n* parser.next( '1,2,3,4\\n' );\n*\n* // ...\n*\n* parser.next( '5,6,7,8\\n' );\n*\n* // ...\n*\n* parser.next( '9,10,11,12\\n' );\n*/\nsetReadOnly( Parser.prototype, 'next', function next( chunk ) {\n\tvar states;\n\tvar i;\n\n\tdebug( 'Chunk: %s', chunk );\n\n\tif ( this.done ) {\n\t\tthis._setErrorState( CLOSED )._changeState( ERROR );\n\t\treturn this;\n\t}\n\tstates = this._states;\n\tfor ( i = 0; i < chunk.length; i++ ) {\n\t\tstates[ this._state ]( chunk[ i ] );\n\t\tif ( this._state === CLOSED || this._state === ERROR ) {\n\t\t\treturn this;\n\t\t}\n\t}\n\treturn this;\n});\n\n/**\n* Closes the parser.\n*\n* @name close\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*\n* @example\n* var parser = new Parser();\n*\n* // ...\n*\n* parser.next( '1,2,3,4\\n' );\n*\n* // ...\n*\n* parser.next( '5,6,7,8\\n' );\n*\n* // ...\n*\n* parser.next( '9,10,11,12\\n' );\n*\n* // ...\n*\n* parser.close();\n*/\nsetReadOnly( Parser.prototype, 'close', function close() {\n\tif ( this.done ) {\n\t\treturn this;\n\t}\n\tthis._changeState( CLOSED );\n\treturn this;\n});\n\n/**\n* Boolean indicating whether a parser is able to process new chunks.\n*\n* @name done\n* @memberof Parser.prototype\n* @readonly\n* @type {boolean}\n*\n* @example\n* var parser = new Parser();\n*\n* // ...\n*\n* parser.next( '1,2,3,4\\n' );\n*\n* // ...\n*\n* parser.next( '5,6,7,8\\n' );\n*\n* // ...\n*\n* parser.next( '9,10,11,12\\n' );\n*\n* // ...\n*\n* parser.close();\n*\n* // ...\n*\n* var bool = parser.done;\n* // returns true\n*/\nsetReadOnlyAccessor( Parser.prototype, 'done', function get() {\n\treturn ( this._state === CLOSED ) || ( this._state === ERROR );\n});\n\n\n// EXPORTS //\n\nexport default Parser;\n"],"names":["throwError","err","state2enum","out","i","enum2state","length","table","CLOSED","debug","require$$0","INIT","ERROR","max","x","y","FIELD","ESCAPE","QUOTED_FIELD","COMMENT","SKIP","removeWhitespace","parser","state","_isWhitespace","_qidx","_cursor","_raiseWarning","_rewind","_changeState","_setErrorState","INVALID_QUOTE_END","QUOTE_END","QUOTED_ESCAPE","SKIPPED_COMMENT","SKIPPED_FIELD","SKIPPED_ESCAPE","SKIPPED_QUOTED_FIELD","SKIPPED_INVALID_QUOTE_END","SKIPPED_QUOTE_END","SKIPPED_QUOTED_ESCAPE","closed","comment","newlineLastIndex","newline","_newlineLastIndex","_newline","ch","_scan","_push","escape","delimiterLastIndex","commentLastIndex","escapeLastIndex","skipLastIndex","escapeLength","delimiter","strict","skip","_delimiterLastIndex","_delimiter","_commentLastIndex","_comment","_skipLastIndex","_skip","_escapeLastIndex","_escapeLength","_escape","_strict","maximum","cursor","idx","_eidx","d","_copyWithin","error","field","quoteLastIndex","quoting","quote","_quoteLastIndex","_quote","_quoting","_cidx","init","invalid_quote_end","quote_end","doublequote","_doublequote","quoted_escape","quoted_field","skipped_comment","skipped_escape","skipped_field","skipped_invalid_quote_end","skipped_quote_end","skipped_quoted_escape","skipped_quoted_field","Parser","options","opts","this","ltrim","maxRows","onClose","noop","onColumn","onComment","onError","onRow","onSkip","onWarn","rowBuffer","rtrim","skipBlankRows","skipRow","trimComment","whitespace","_buffer","_rowBufferFLG","Boolean","_rowBuffer","_col","_row","_line","_commented","_skipped","_errname","_ltrim","_maxRows","_rtrim","_skipBlankRows","_skipRow","_trimComment","_whitespace","list","pattern","rescape","array2pattern","_reWhitespace","RegExp","_reWhitespaceLeft","_reWhitespaceRight","_onClose","_onColumn","_onComment","_onRow","_onSkip","_onError","_onWarn","_commentLength","_delimiterLength","_newlineLength","_quoteLength","_skipLength","_state","_states","push","states","arguments","setReadOnly","prototype","buf","N","target","start","end","slice","join","replace","_slice","value","v","search","_getField","_setField","_getRow","_reset","_onSkippedRow","name","Error","format","_createException","message","_close","_raiseException","_onEscape","_onField","_onCommentedRow","_onRecord","_onClosingQuote","done","chunk","setReadOnlyAccessor"],"mappings":"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"}