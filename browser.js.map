{"version":3,"file":"browser.js","sources":["../node_modules/@stdlib/utils-define-property/lib/index.js","../node_modules/@stdlib/utils-define-property/lib/define_property.js","../node_modules/@stdlib/utils-define-property/lib/builtin.js","../node_modules/@stdlib/utils-define-property/lib/polyfill.js","../node_modules/@stdlib/utils-define-property/lib/has_define_property_support.js","../node_modules/@stdlib/utils-define-nonenumerable-read-only-property/lib/main.js","../node_modules/@stdlib/boolean-ctor/lib/main.js","../node_modules/@stdlib/error-tools-fmtprodmsg/lib/main.js","../node_modules/@stdlib/utils-noop/lib/noop.js","../lib/defaults.js","../lib/states/state2enum.js","../lib/states/closed.js","../lib/states/comment.js","../lib/states/error.js","../lib/states/max.js","../lib/states/escape.js","../lib/states/field.js","../lib/states/init.js","../lib/states/quote_end.js","../lib/states/quoted_escape.js","../lib/states/quoted_field.js","../lib/states/index.js","../lib/main.js","../node_modules/@stdlib/utils-define-nonenumerable-read-only-accessor/lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Define (or modify) an object property.\n*\n* @module @stdlib/utils-define-property\n*\n* @example\n* import defineProperty from '@stdlib/utils-define-property' ;\n*\n* var obj = {};\n* defineProperty( obj, 'foo', {\n*     'value': 'bar',\n*     'writable': false,\n*     'configurable': false,\n*     'enumerable': false\n* });\n* obj.foo = 'boop'; // => throws\n*/\n\n// MODULES //\n\nimport hasDefinePropertySupport from './has_define_property_support.js' ;\nimport builtin from './builtin.js' ;\nimport polyfill from './polyfill.js' ;\n\n\n// MAIN //\n\nvar defineProperty;\nif ( hasDefinePropertySupport() ) {\n\tdefineProperty = builtin;\n} else {\n\tdefineProperty = polyfill;\n}\n\n\n// EXPORTS //\n\nexport default defineProperty;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\nvar main = ( typeof Object.defineProperty === 'function' ) ? Object.defineProperty : null;\n\n\n// EXPORTS //\n\nexport default main;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Defines (or modifies) an object property.\n*\n* ## Notes\n*\n* -   Property descriptors come in two flavors: **data descriptors** and **accessor descriptors**. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter function pair. A descriptor must be one of these two flavors and cannot be both.\n*\n* @name defineProperty\n* @type {Function}\n* @param {Object} obj - object on which to define the property\n* @param {(string|symbol)} prop - property name\n* @param {Object} descriptor - property descriptor\n* @param {boolean} [descriptor.configurable=false] - boolean indicating if property descriptor can be changed and if the property can be deleted from the provided object\n* @param {boolean} [descriptor.enumerable=false] - boolean indicating if the property shows up when enumerating object properties\n* @param {boolean} [descriptor.writable=false] - boolean indicating if the value associated with the property can be changed with an assignment operator\n* @param {*} [descriptor.value] - property value\n* @param {(Function|void)} [descriptor.get=undefined] - function which serves as a getter for the property, or, if no getter, undefined. When the property is accessed, a getter function is called without arguments and with the `this` context set to the object through which the property is accessed (which may not be the object on which the property is defined due to inheritance). The return value will be used as the property value.\n* @param {(Function|void)} [descriptor.set=undefined] - function which serves as a setter for the property, or, if no setter, undefined. When assigning a property value, a setter function is called with one argument (the value being assigned to the property) and with the `this` context set to the object through which the property is assigned.\n* @throws {TypeError} first argument must be an object\n* @throws {TypeError} third argument must be an object\n* @throws {Error} property descriptor cannot have both a value and a setter and/or getter\n* @returns {Object} object with added property\n*\n* @example\n* var obj = {};\n*\n* defineProperty( obj, 'foo', {\n*     'value': 'bar'\n* });\n*\n* var str = obj.foo;\n* // returns 'bar'\n*/\nvar defineProperty = Object.defineProperty;\n\n\n// EXPORTS //\n\nexport default defineProperty;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle, no-proto */\n\n'use strict';\n\n// VARIABLES //\n\nvar objectProtoype = Object.prototype;\nvar toStr = objectProtoype.toString;\nvar defineGetter = objectProtoype.__defineGetter__;\nvar defineSetter = objectProtoype.__defineSetter__;\nvar lookupGetter = objectProtoype.__lookupGetter__;\nvar lookupSetter = objectProtoype.__lookupSetter__;\n\n\n// MAIN //\n\n/**\n* Defines (or modifies) an object property.\n*\n* ## Notes\n*\n* -   Property descriptors come in two flavors: **data descriptors** and **accessor descriptors**. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter function pair. A descriptor must be one of these two flavors and cannot be both.\n*\n* @param {Object} obj - object on which to define the property\n* @param {string} prop - property name\n* @param {Object} descriptor - property descriptor\n* @param {boolean} [descriptor.configurable=false] - boolean indicating if property descriptor can be changed and if the property can be deleted from the provided object\n* @param {boolean} [descriptor.enumerable=false] - boolean indicating if the property shows up when enumerating object properties\n* @param {boolean} [descriptor.writable=false] - boolean indicating if the value associated with the property can be changed with an assignment operator\n* @param {*} [descriptor.value] - property value\n* @param {(Function|void)} [descriptor.get=undefined] - function which serves as a getter for the property, or, if no getter, undefined. When the property is accessed, a getter function is called without arguments and with the `this` context set to the object through which the property is accessed (which may not be the object on which the property is defined due to inheritance). The return value will be used as the property value.\n* @param {(Function|void)} [descriptor.set=undefined] - function which serves as a setter for the property, or, if no setter, undefined. When assigning a property value, a setter function is called with one argument (the value being assigned to the property) and with the `this` context set to the object through which the property is assigned.\n* @throws {TypeError} first argument must be an object\n* @throws {TypeError} third argument must be an object\n* @throws {Error} property descriptor cannot have both a value and a setter and/or getter\n* @returns {Object} object with added property\n*\n* @example\n* var obj = {};\n*\n* defineProperty( obj, 'foo', {\n*     'value': 'bar'\n* });\n*\n* var str = obj.foo;\n* // returns 'bar'\n*/\nfunction defineProperty( obj, prop, descriptor ) {\n\tvar prototype;\n\tvar hasValue;\n\tvar hasGet;\n\tvar hasSet;\n\n\tif ( typeof obj !== 'object' || obj === null || toStr.call( obj ) === '[object Array]' ) {\n\t\tthrow new TypeError( 'invalid argument. First argument must be an object. Value: `' + obj + '`.' );\n\t}\n\tif ( typeof descriptor !== 'object' || descriptor === null || toStr.call( descriptor ) === '[object Array]' ) {\n\t\tthrow new TypeError( 'invalid argument. Property descriptor must be an object. Value: `' + descriptor + '`.' );\n\t}\n\thasValue = ( 'value' in descriptor );\n\tif ( hasValue ) {\n\t\tif (\n\t\t\tlookupGetter.call( obj, prop ) ||\n\t\t\tlookupSetter.call( obj, prop )\n\t\t) {\n\t\t\t// Override `__proto__` to avoid touching inherited accessors:\n\t\t\tprototype = obj.__proto__;\n\t\t\tobj.__proto__ = objectProtoype;\n\n\t\t\t// Delete property as existing getters/setters prevent assigning value to specified property:\n\t\t\tdelete obj[ prop ];\n\t\t\tobj[ prop ] = descriptor.value;\n\n\t\t\t// Restore original prototype:\n\t\t\tobj.__proto__ = prototype;\n\t\t} else {\n\t\t\tobj[ prop ] = descriptor.value;\n\t\t}\n\t}\n\thasGet = ( 'get' in descriptor );\n\thasSet = ( 'set' in descriptor );\n\n\tif ( hasValue && ( hasGet || hasSet ) ) {\n\t\tthrow new Error( 'invalid argument. Cannot specify one or more accessors and a value or writable attribute in the property descriptor.' );\n\t}\n\n\tif ( hasGet && defineGetter ) {\n\t\tdefineGetter.call( obj, prop, descriptor.get );\n\t}\n\tif ( hasSet && defineSetter ) {\n\t\tdefineSetter.call( obj, prop, descriptor.set );\n\t}\n\treturn obj;\n}\n\n\n// EXPORTS //\n\nexport default defineProperty;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport defineProperty from './define_property.js' ;\n\n\n// MAIN //\n\n/**\n* Tests for `Object.defineProperty` support.\n*\n* @private\n* @returns {boolean} boolean indicating if an environment has `Object.defineProperty` support\n*\n* @example\n* var bool = hasDefinePropertySupport();\n* // returns <boolean>\n*/\nfunction hasDefinePropertySupport() {\n\t// Test basic support...\n\ttry {\n\t\tdefineProperty( {}, 'x', {} );\n\t\treturn true;\n\t} catch ( err ) { // eslint-disable-line no-unused-vars\n\t\treturn false;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default hasDefinePropertySupport;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport defineProperty from '@stdlib/utils-define-property' ;\n\n\n// MAIN //\n\n/**\n* Defines a non-enumerable read-only property.\n*\n* @param {Object} obj - object on which to define the property\n* @param {(string|symbol)} prop - property name\n* @param {*} value - value to set\n*\n* @example\n* var obj = {};\n*\n* setNonEnumerableReadOnly( obj, 'foo', 'bar' );\n*\n* try {\n*     obj.foo = 'boop';\n* } catch ( err ) {\n*     console.error( err.message );\n* }\n*/\nfunction setNonEnumerableReadOnly( obj, prop, value ) {\n\tdefineProperty( obj, prop, {\n\t\t'configurable': false,\n\t\t'enumerable': false,\n\t\t'writable': false,\n\t\t'value': value\n\t});\n}\n\n\n// EXPORTS //\n\nexport default setNonEnumerableReadOnly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns a boolean.\n*\n* @name Boolean\n* @constructor\n* @type {Function}\n* @param {*} value - input value\n* @returns {(boolean|Boolean)} boolean\n*\n* @example\n* var b = Boolean( null );\n* // returns false\n*\n* b = Boolean( [] );\n* // returns true\n*\n* b = Boolean( {} );\n* // returns true\n*\n* @example\n* var b = new Boolean( false );\n* // returns <Boolean>\n*/\nvar Bool = Boolean; // eslint-disable-line stdlib/require-globals\n\n\n// EXPORTS //\n\nexport default Bool;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Formats an error message for production.\n*\n* @param {string} code - error code\n* @param {*} ...args - error message arguments\n* @returns {string} formatted error message\n*\n* @example\n* var msg = fmtprodmsg( '3', 'wrong_type' );\n* // returns 'https://stdlib.io/e/3?&arg[]=wrong_type'\n*/\nfunction fmtprodmsg() {\n\tvar a = arguments;\n\tvar c = a[ 0 ];\n\tvar u = 'https://stdlib.io/e/'+c+'?';\n\tvar i;\n\tfor ( i = 1; i < a.length; i++ ) {\n\t\tu += '&arg[]=' + encodeURIComponent( a[ i ] );\n\t}\n\treturn u;\n}\n\n\n// EXPORTS //\n\nexport default fmtprodmsg;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* No operation.\n*\n* @example\n* noop();\n* // ...does nothing.\n*/\nfunction noop() {\n\t// Empty function...\n}\n\n\n// EXPORTS //\n\nexport default noop;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport noop from '@stdlib/utils-noop' ;\n\n\n// FUNCTIONS //\n\n/**\n* Throws a provided exception.\n*\n* @private\n* @param {Error} err - error object\n* @throws {Error} exception\n*/\nfunction throwError( err ) {\n\tthrow err;\n}\n\n\n// MAIN //\n\n/**\n* Returns default options.\n*\n* @private\n* @returns {Object} default options\n*\n* @example\n* var o = defaults();\n* // returns {...}\n*/\nfunction defaults() {\n\treturn {\n\t\t// Character sequence appearing at the beginning of a row which demarcates that the row content should be parsed as a commented line. A commented line ends upon encountering the first newline character sequence, regardless of whether that newline character sequence is preceded by an escape character sequence.\n\t\t'comment': '',\n\n\t\t// Character sequence demarcating a decimal point in numeric values (e.g., use `'.'` for US data and `','` for European data).\n\t\t'decimal': '.',\n\n\t\t// Character sequence separating record fields (e.g., use `','` for CSV and use `'\\t'` for TSV).\n\t\t'delimiter': ',',\n\n\t\t// Flag indicating how quote sequences should be escaped within a quoted field. When `true`, a quote sequence must be escaped by another quote sequence. When `false`, a quote sequence must be escaped by the escape sequence.\n\t\t'doublequote': true,\n\n\t\t// Character sequence for escaping character sequences having special meaning (i.e., delimiter, newline, escape, and comment outside of quoted fields, and the quote sequence within quoted fields when `doublequote` is `false`).\n\t\t'escape': '',\n\n\t\t// When converting a column value to a boolean, a list of string values which should be converted to `false`. May also be a regular expression.\n\t\t'false': [ 'false' ],\n\n\t\t// When processing a column value, a list of string values which should be interpreted as indicating a missing value (i.e., an empty field; e.g., `[ '', 'null', 'NULL', 'NaN', 'NA', 'na' ]`). May also be a regular expression.\n\t\t'missing': [ '' ],\n\n\t\t// Character sequence separating rows.\n\t\t'newline': '\\r\\n',\n\n\t\t// Callback to be invoked upon closing the parser.\n\t\t'onClose': noop,\n\n\t\t// Callback to be invoked upon processing a field.\n\t\t'onColumn': noop,\n\n\t\t// Callback to be invoked upon processing a commented line.\n\t\t'onComment': null,\n\n\t\t// Callback to be invoked upon encountering an unrecoverable parse error.\n\t\t'onError': throwError,\n\n\t\t// When `strict` is `false`, a callback to be invoked upon encountering invalid DSV.\n\t\t'onWarn': null,\n\n\t\t// Callback to be invoked upon processing a record.\n\t\t'onRow': noop,\n\n\t\t// Character sequence demarcating the beginning and ending of a quoted field.\n\t\t'quote': '\"',\n\n\t\t// Flag indicating whether to enable special processing of quote character sequences (i.e., whether a quote sequence should demarcate a quoted field).\n\t\t'quoting': true,\n\n\t\t// Array-like object for storing the field values of the most recently processed record. This allows reusing memory and avoiding copies upon invocation of the `onRow` callback.\n\t\t'rowBuffer': [],\n\n\t\t// Schema specifying field data types.\n\t\t'schema': null,\n\n\t\t// Flag indicating whether to raise an exception upon encountering invalid DSV.\n\t\t'strict': true,\n\n\t\t// Character sequence demarcating a thousands separator in numeric values (e.g., use `'_'` for `1_000_000` or `','` for `1,000,000`).\n\t\t'thousands': '',\n\n\t\t// Flag indicating whether to trim leading whitespace from field values. If `false`, leading whitespace is not trimmed (e.g., `a, b, c` parses as`[ 'a', ' b', ' c' ]`). If `true`, leading whitespace is trimmed (e.g., `a, b, c`parses as `[ 'a', 'b', 'c' ]`).\n\t\t'trim': false,\n\n\t\t// Flag indicating whether to trim leading and trailing whitespace in commented lines.\n\t\t'trimComment': true,\n\n\t\t// Flag indicating whether to trim non-numeric characters from numeric values. If `false`, non-numeric characters are not trimmed (e.g., `$2.00` => `[ '$2.00' ]`). If `true`, non-numeric characters are trimmed (e.g., `$2.00` => `[ '2.00' ] `).\n\t\t'trimNonNumeric': false,\n\n\t\t// When converting a column value to a boolean, a list of string values which should be converted to `true`. May also be a regular expression.\n\t\t'true': [ 'true' ],\n\n\t\t// List of characters to be treated as whitespace. May also be a regular expression.\n\t\t'whitespace': [ ' ' ]\n\t};\n}\n\n\n// EXPORTS //\n\nexport default defaults;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport enum2state from './enum2state.json' ;\n\n\n// FUNCTIONS //\n\n/**\n* Returns a table mapping state names to enumeration constants.\n*\n* @private\n* @returns {Object} mapping table\n*/\nfunction table() {\n\tvar out;\n\tvar i;\n\n\tout = {};\n\tfor ( i = 0; i < enum2state.length; i++ ) {\n\t\tout[ enum2state[ i ] ] = i;\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Table mapping state names to enumeration constants.\n*\n* @private\n* @name state2enum\n* @type {Object}\n*/\nvar state2enum = table(); // eslint-disable-line vars-on-top\n\n\n// EXPORTS //\n\nexport default state2enum;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport state2enum from './state2enum.js' ;\n\n\n// VARIABLES //\n\n// Possible transition states...\nvar CLOSED = state2enum[ 'closed' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for closing a parser.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next() {\n\t\tparser._changeState( CLOSED );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport logger from 'debug' ;\nimport state2enum from './state2enum.js' ;\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:comment' );\n\n// Possible transition states...\nvar INIT = state2enum[ 'init' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a commented line.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar newlineLastIndex;\n\tvar newline;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t// Check for the end of the commented line...\n\t\tif ( ch === newline[ newlineLastIndex] && parser._scan( newline, newlineLastIndex ) ) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport state2enum from './state2enum.js' ;\n\n\n// VARIABLES //\n\n// Possible transition states...\nvar ERROR = state2enum[ 'error' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for a parser error state.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next() {\n\t\tparser._changeState( ERROR );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns the maximum value.\n*\n* @private\n* @param {NonNegativeInteger} x - first value\n* @param {NonNegativeInteger} y - second value\n* @returns {NonNegativeInteger} maximum value\n*\n* @example\n* var v = max( 2, 3 );\n* // returns 3\n*\n* @example\n* var v = max( 3, 2 );\n* // returns 3\n*\n* @example\n* var v = max( 2, 2 );\n* // returns 2\n*/\nfunction max( x, y ) {\n\treturn ( x < y ) ? y : x;\n}\n\n\n// EXPORTS //\n\nexport default max;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport logger from 'debug' ;\nimport maximum from './max.js' ;\nimport state2enum from './state2enum.js' ;\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:escape' );\n\n// Possible transition states...\nvar ERROR = state2enum[ 'error' ];\nvar FIELD = state2enum[ 'field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing an escape sequence.\n*\n* ## Notes\n*\n* -   An escape sequence escapes the delimiter, newline, and escape sequences in **non-quoted** fields.\n* -   An escape sequence escapes a comment sequence in **non-quoted** fields when an escape sequence occurs at the beginning of a record.\n* -   In strict mode, if not immediately followed by a special character sequence, then the parser raises an exception.\n* -   In non-strict mode, if not immediately followed by a special character sequence, then the escape sequence has no special meaning and is considered a normal character sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar commentLastIndex;\n\tvar escapeLastIndex;\n\tvar escapeLength;\n\tvar delimiter;\n\tvar newline;\n\tvar comment;\n\tvar escape;\n\tvar strict;\n\tvar max;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tcommentLastIndex = parser._commentLastIndex;\n\tcomment = parser._comment;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescapeLength = parser._escapeLength;\n\tescape = parser._escape;\n\n\tstrict = parser._strict;\n\n\tmax = maximum( maximum( delimiterLastIndex, newlineLastIndex ), escapeLastIndex ); // eslint-disable-line max-len\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar cursor = parser._cursor;\n\t\tvar idx = parser._eidx; // position of last escape character\n\t\tvar d = cursor - idx;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\td === delimiterLastIndex &&\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._copyWithin( idx-escapeLastIndex, idx+1, delimiterLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\td === newlineLastIndex &&\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._copyWithin( idx-escapeLastIndex, idx+1, newlineLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for an escape sequence.\n\t\t*/\n\t\tif (\n\t\t\td === escapeLastIndex &&\n\t\t\tch === escape[ escapeLastIndex ] &&\n\t\t\tparser._scan( escape, escapeLastIndex )\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._copyWithin( idx-escapeLastIndex, idx+1, escapeLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a comment sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Comment sequences only have special meaning when appearing at the beginning of a row.\n\t\t*/\n\t\tif (\n\t\t\tcomment &&                                 // user specified a comment character sequence, so should check for comments\n\t\t\tcursor-commentLastIndex === 0 &&           // only search the first character(s) of the row\n\t\t\tch === comment[ commentLastIndex ] &&      // we have a potential match\n\t\t\tparser._scan( comment, commentLastIndex )  // we found a match\n\t\t) {\n\t\t\tdebug( 'Comment.' );\n\t\t\tparser._copyWithin( idx-commentLastIndex, idx+1, commentLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a non-special character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In strict mode, field separators, row separators, and escaped sequences must immediately follow an escape sequence. At some point, we'll have processed a greater number of characters than exists in any of the special character sequences, meaning that none of those sequences immediately follow the escape sequence which led to the current state. Once this happens, we're in an invalid state and must raise an exception, as not clear how the parser should interpret the preceding values (e.g., was the preceding escape sequence supposed to be escaped? was the preceding escape sequence a mistake and should be ignored? are we missing a delimiter or newline sequence? etc.).\n\t\t* -   In non-strict mode, we assume that the escape sequence is a normal character sequence.\n\t\t*/\n\t\tif ( d >= max ) {\n\t\t\tif ( strict ) {\n\t\t\t\tdebug( 'Error.' );\n\t\t\t\tparser._setErrorState( 'INVALID_ESCAPE' )._changeState( ERROR );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Return to normal field processing:\n\t\t\tdebug( 'Escape sequence is not followed by a special character sequence.' );\n\t\t\tparser._raiseWarning( 'INVALID_ESCAPE' )._push( ch )._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport logger from 'debug' ;\nimport state2enum from './state2enum.js' ;\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:field' );\n\n// Possible transition states...\nvar ESCAPE = state2enum[ 'escape' ];\nvar FIELD = state2enum[ 'field' ];\nvar INIT = state2enum[ 'init' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a field.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar delimiter;\n\tvar newline;\n\tvar quoting;\n\tvar escape;\n\tvar quote;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tquoting = parser._quoting;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar idx = parser._cursor - parser._cidx + 1;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for an escape character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   An escape sequence escapes the delimiter, newline, and escape sequences in **non-quoted** fields.\n\t\t* -   When `doublequote` is `false`, the escape sequence escapes quote sequences within **quoted** fields.\n\t\t* -   In strict mode, if not immediately followed by a special character sequence, then the parser raises an exception.\n\t\t* -   In non-strict mode, if not immediately followed by a special character sequence, then the escape sequence has no special meaning.\n\t\t*/\n\t\tif (\n\t\t\tch === escape[ escapeLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( escape, escapeLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( ESCAPE );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a quote character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tidx-quoteLastIndex === 0 &&           // only search the first character(s) of the field\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tif ( quoting ) {\n\t\t\t\t// Rewind the cursor to point to the last character before the quote character sequence:\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._rewind( quoteLastIndex )._changeState( QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\tparser._push( ch );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the delimiter character sequence:\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._rewind( delimiterLastIndex )._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport logger from 'debug' ;\nimport state2enum from './state2enum.js' ;\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:init' );\n\n// Possible transition states...\nvar COMMENT = state2enum[ 'comment' ];\nvar FIELD = state2enum[ 'field' ];\nvar ESCAPE = state2enum[ 'escape' ];\nvar INIT = state2enum[ 'init' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing the initial characters of a row.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar commentLastIndex;\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar delimiter;\n\tvar newline;\n\tvar comment;\n\tvar quoting;\n\tvar escape;\n\tvar quote;\n\n\tcommentLastIndex = parser._commentLastIndex;\n\tcomment = parser._comment;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tquoting = parser._quoting;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar idx = parser._cursor + 1;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for the start of a commented line.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In order for a row to be considered a commented line, the comment sequence must be the first character(s) of the field.\n\t\t*/\n\t\tif (\n\t\t\tcomment &&                                // user specified a comment character sequence, so should check for comments\n\t\t\tidx-commentLastIndex === 0 &&             // only search the first character(s) of the first field\n\t\t\tch === comment[ commentLastIndex ] &&     // we have a potential comment match\n\t\t\tparser._scan( comment, commentLastIndex ) // we found a match\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the comment character sequence:\n\t\t\tdebug( 'Comment.' );\n\t\t\tparser._rewind( commentLastIndex )._changeState( COMMENT );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for an escape character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   An escape sequence escapes the delimiter, newline, and escape sequences in **non-quoted** fields.\n\t\t* -   An escape sequence escapes a comment sequence in **non-quoted** fields when an escape sequence occurs at the beginning of a record.\n\t\t* -   When `doublequote` is `false`, the escape sequence escapes quote sequences within **quoted** fields.\n\t\t* -   In strict mode, if not immediately followed by a special character sequence, then the parser raises an exception.\n\t\t* -   In non-strict mode, if not immediately followed by a special character sequence, then the escape sequence has no special meaning.\n\t\t*/\n\t\tif (\n\t\t\tch === escape[ escapeLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( escape, escapeLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( ESCAPE );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a quote character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   When `quoting` is `true`, in order for a field to be quoted, the quote sequence must be the first character(s) of the field.\n\t\t* -   When `quoting` is `false`, quote sequences do **not** have any special meaning, and we process quote sequences as normal field text.\n\t\t*/\n\t\tif (\n\t\t\tidx-quoteLastIndex === 0 &&           // only search the first character(s) of the field\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\tif ( quoting ) {\n\t\t\t\t// Rewind the cursor to point to the last character before the quote character sequence:\n\t\t\t\tdebug( 'Quote.' );\n\t\t\t\tparser._rewind( quoteLastIndex )._changeState( QUOTED_FIELD );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Continue processing until we can transition to a new state:\n\t\t\tparser._push( ch );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the delimiter character sequence:\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._rewind( delimiterLastIndex )._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport logger from 'debug' ;\nimport maximum from './max.js' ;\nimport state2enum from './state2enum.js' ;\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:quote_end' );\n\n// Possible transition states...\nvar ERROR = state2enum[ 'error' ];\nvar FIELD = state2enum[ 'field' ];\nvar INIT = state2enum[ 'init' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing an ending quote sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar delimiterLastIndex;\n\tvar newlineLastIndex;\n\tvar quoteLastIndex;\n\tvar doublequote;\n\tvar delimiter;\n\tvar newline;\n\tvar quote;\n\tvar max;\n\n\tdelimiterLastIndex = parser._delimiterLastIndex;\n\tdelimiter = parser._delimiter;\n\n\tnewlineLastIndex = parser._newlineLastIndex;\n\tnewline = parser._newline;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdoublequote = parser._doublequote;\n\n\tmax = maximum( maximum( delimiterLastIndex, newlineLastIndex ), quoteLastIndex ); // eslint-disable-line max-len\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a quote character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   When `doublequote` is `true`, quote character sequences are escaped by a preceding quote character sequence.\n\t\t* -   When `doublequote` is `false`, quote character sequences must be explicitly escaped using an escape character sequence.\n\t\t*/\n\t\tif (\n\t\t\tdoublequote &&\n\t\t\tch === quote[ quoteLastIndex ] &&\n\t\t\tparser._scan( quote, quoteLastIndex )\n\t\t) {\n\t\t\t// Keep the escaped quote character sequence and transition back to a quoted field state:\n\t\t\tdebug( 'Double quote.' );\n\t\t\tparser._push( ch )._changeState( QUOTED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a field delimiter.\n\t\t*/\n\t\tif (\n\t\t\tch === delimiter[ delimiterLastIndex ] &&\n\t\t\tparser._scan( delimiter, delimiterLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the delimiter character sequence:\n\t\t\tdebug( 'Delimiter.' );\n\t\t\tparser._rewind( delimiterLastIndex )._changeState( FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a row separator.\n\t\t*/\n\t\tif (\n\t\t\tch === newline[ newlineLastIndex ] &&\n\t\t\tparser._scan( newline, newlineLastIndex )\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the newline character sequence:\n\t\t\tdebug( 'Newline.' );\n\t\t\tparser._rewind( newlineLastIndex )._changeState( INIT );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a non-special character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   Field separators, row separators, and escaped quote sequences must immediately follow a potential closing quote sequence. At some point, we'll have processed a greater number of characters than exists in any of the special character sequences, meaning that none of those sequences immediately follow the quote sequence which led to the current state. Once this happens, we're in an invalid state and must raise an exception, as not clear how the parser should interpret the preceding values (e.g., was the preceding quote supposed to be escaped? was the preceding quote a mistake and should be ignored? are we missing a delimiter or newline sequence? etc.).\n\t\t*/\n\t\tif ( parser._cursor-parser._qidx >= max ) {\n\t\t\t// TODO: in non-strict mode, may want to allow whitespace (which we'd trim via rewind!) until a field/row separator. How could this work? First check whether all preceding characters and the current character is whitespace. Rewind cursor. Transition to a new state which only allows whitespace and a delimiter/newline. Ignore incoming whitespace. Once delimiter/newline, transition back to normal field processing.\n\n\t\t\tdebug( 'Error.' );\n\t\t\tparser._setErrorState( 'INVALID_CLOSING_QUOTE' )._changeState( ERROR );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport logger from 'debug' ;\nimport state2enum from './state2enum.js' ;\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:quoted_escape' );\n\n// Possible transition states...\nvar ERROR = state2enum[ 'error' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing an escape sequence within a quoted field.\n*\n* ## Notes\n*\n* -   Within a quoted field, an escape sequence (only) escapes the quote sequence.\n* -   In strict mode, if not immediately followed by a special character sequence, then the parser raises an exception.\n* -   In non-strict mode, if not immediately followed by a special character sequence, then the escape sequence has no special meaning and is considered a normal character sequence.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar escapeLength;\n\tvar strict;\n\tvar quote;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescapeLength = parser._escapeLength;\n\n\tstrict = parser._strict;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tvar cursor = parser._cursor;\n\t\tvar idx = parser._eidx; // position of last escape character\n\t\tvar d = cursor - idx;\n\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for a quote sequence.\n\t\t*/\n\t\tif (\n\t\t\td === quoteLastIndex &&\n\t\t\tch === quote[ quoteLastIndex ] &&\n\t\t\tparser._scan( quote, quoteLastIndex )\n\t\t) {\n\t\t\tdebug( 'Quote.' );\n\t\t\tparser._copyWithin( idx-escapeLastIndex, idx+1, quoteLastIndex )\n\t\t\t\t._rewind( escapeLength )\n\t\t\t\t._push( ch )\n\t\t\t\t._changeState( QUOTED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for a non-special character sequence.\n\t\t*\n\t\t* ## Notes\n\t\t*\n\t\t* -   In strict mode, quote sequences must immediately follow an escape sequence. At some point, we'll have processed a greater number of characters than exists in a quote sequence, meaning that a quote sequence does not immediately follow the escape sequence which led to the current state. Once this happens, we're in an invalid state and must raise an exception, as not clear how the parser should interpret the preceding values (e.g., was the preceding escape sequence a mistake and should be ignored? are we missing a quote sequence? etc.).\n\t\t* -   In non-strict mode, we assume that the escape sequence is a normal character sequence.\n\t\t*/\n\t\tif ( d >= quoteLastIndex ) {\n\t\t\tif ( strict ) {\n\t\t\t\tdebug( 'Error.' );\n\t\t\t\tparser._setErrorState( 'INVALID_QUOTED_ESCAPE' )._changeState( ERROR );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Return to normal field processing:\n\t\t\tdebug( 'Escape sequence is not followed by a quote sequence.' );\n\t\t\tparser._raiseWarning( 'INVALID_QUOTED_ESCAPE' )._push( ch )._changeState( QUOTED_FIELD );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\n// MODULES //\n\nimport logger from 'debug' ;\nimport state2enum from './state2enum.js' ;\n\n\n// VARIABLES //\n\nvar debug = logger( 'state:quoted_field' );\n\n// Possible transition states...\nvar QUOTE_END = state2enum[ 'quote_end' ];\nvar QUOTED_ESCAPE = state2enum[ 'quoted_escape' ];\n\n\n// MAIN //\n\n/**\n* Returns a function for processing a quoted field.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Function} processing function\n*/\nfunction processor( parser ) {\n\tvar escapeLastIndex;\n\tvar quoteLastIndex;\n\tvar doublequote;\n\tvar escape;\n\tvar quote;\n\n\tescapeLastIndex = parser._escapeLastIndex;\n\tescape = parser._escape;\n\n\tquoteLastIndex = parser._quoteLastIndex;\n\tquote = parser._quote;\n\n\tdoublequote = parser._doublequote;\n\n\treturn next;\n\n\t/**\n\t* Processes a character.\n\t*\n\t* @private\n\t* @param {string} ch - character\n\t* @returns {void}\n\t*/\n\tfunction next( ch ) {\n\t\tdebug( 'Char: %s', ch );\n\n\t\t/*\n\t\t* Check for an escape character sequence.\n\t\t*/\n\t\tif (\n\t\t\tdoublequote === false &&                // double quoting is disabled\n\t\t\tch === escape[ escapeLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( escape, escapeLastIndex ) // we found a match\n\t\t) {\n\t\t\tdebug( 'Escape.' );\n\t\t\tparser._push( ch )._changeState( QUOTED_ESCAPE );\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t* Check for an ending quote character sequence.\n\t\t*/\n\t\tif (\n\t\t\tch === quote[ quoteLastIndex ] &&     // we have a potential match\n\t\t\tparser._scan( quote, quoteLastIndex ) // we found a match\n\t\t) {\n\t\t\t// Rewind the cursor to point to the last character before the quote character sequence:\n\t\t\tdebug( 'Quote.' );\n\t\t\tparser._rewind( quoteLastIndex )._changeState( QUOTE_END );\n\t\t\treturn;\n\t\t}\n\t\t// Continue processing until we can transition to a new state:\n\t\tparser._push( ch );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default processor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport enum2state from './enum2state.json' ;\nimport closed from './closed.js' ; // eslint-disable-line stdlib/no-redeclare\nimport comment from './comment.js' ;\nimport error from './error.js' ;\nimport escape from './escape.js' ; // eslint-disable-line stdlib/no-redeclare\nimport field from './field.js' ;\nimport init from './init.js' ;\nimport quoteEnd from './quote_end.js' ;\nimport quotedEscape from './quoted_escape.js' ;\nimport quotedField from './quoted_field.js' ;\n\n\n// VARIABLES //\n\nvar table = {\n\t'closed': closed,\n\t'comment': comment,\n\t'escape': escape,\n\t'error': error,\n\t'field': field,\n\t'init': init,\n\t'quote_end': quoteEnd,\n\t'quoted_escape': quotedEscape,\n\t'quoted_field': quotedField\n};\n\n\n// MAIN //\n\n/**\n* Returns an object mapping state enumeration constants to state functions.\n*\n* @private\n* @param {Parser} parser - parser instance\n* @returns {Array<Function>} table\n*/\nfunction states( parser ) {\n\tvar out;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < enum2state.length; i++ ) {\n\t\tout.push( table[ enum2state[ i ] ]( parser ) );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default states;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this, max-len, no-underscore-dangle, max-lines */\n\n'use strict';\n\n// MODULES //\n\nimport logger from 'debug' ;\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property' ;\nimport setReadOnlyAccessor from '@stdlib/utils-define-nonenumerable-read-only-accessor' ;\nimport Boolean from '@stdlib/boolean-ctor' ;\nimport format from '@stdlib/error-tools-fmtprodmsg' ;\nimport defaults from './defaults.js' ;\nimport state2enum from './states/state2enum.js' ;\nimport enum2state from './states/enum2state.json' ;\nimport states from './states' ;\n\n\n// VARIABLES //\n\nvar debug = logger( 'parser' );\n\n// Parser states:\nvar CLOSED = state2enum[ 'closed' ];\nvar COMMENT = state2enum[ 'comment' ];\nvar ERROR = state2enum[ 'error' ];\nvar ESCAPE = state2enum[ 'escape' ];\nvar FIELD = state2enum[ 'field' ];\nvar INIT = state2enum[ 'init' ];\nvar QUOTE_END = state2enum[ 'quote_end' ];\nvar QUOTED_ESCAPE = state2enum[ 'quoted_escape' ];\nvar QUOTED_FIELD = state2enum[ 'quoted_field' ];\n\n\n// MAIN //\n\n/**\n* Returns an incremental parser for delimiter-separated values.\n*\n* @constructor\n* @param {Options} options - options object\n* @returns {Parser} parser instance\n*\n* @example\n* var parser = new Parser();\n*\n* // ...\n*\n* parser.next( '1,2,3,4\\n' );\n*\n* // ...\n*\n* parser.next( '5,6,7,8\\n' );\n*\n* // ...\n*\n* parser.next( '9,10,11,12\\n' );\n*\n* // ...\n*\n* parser.close();\n*\n* // ...\n*\n* var bool = parser.done;\n* // returns true\n*/\nfunction Parser( options ) {\n\tvar opts;\n\n\tif ( !( this instanceof Parser ) ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn new Parser( options );\n\t\t}\n\t\treturn new Parser();\n\t}\n\t// TODO: option validation; enforce quote, comment, delimiter, escape, and newline all being different and none can be a substring of the other (i.e., no escape equal to `,,` and delimiter equal to `,`, and no delimiter equal to `,` and newline being `,,` and vice versa; is `,,` an escape or simply an empty field?); require thousands and decimal be different and not substrings of the other\n\toptions = options || {};\n\topts = defaults();\n\n\t// Buffer for tracking internal state:\n\tthis._buffer = [];\n\n\t// Index of the most recently processed character:\n\tthis._cursor = -1;\n\n\t// Index marking the beginning of the current field:\n\tthis._cidx = 0;\n\n\t// Indices marking the most recent unescaped quote sequence:\n\tthis._qidx = -1;\n\n\t// Indices marking the most recent escape sequence:\n\tthis._eidx = -1;\n\n\t// Buffer for storing the field values for the current row:\n\tthis._rowBufferFLG = Boolean( options.rowBuffer );\n\tthis._rowBuffer = options.rowBuffer || opts.rowBuffer;\n\n\t// Column, row, and line counters:\n\tthis._col = 0;\n\tthis._row = 0;\n\tthis._line = 0;\n\n\t// Initialize the state flag:\n\tthis._state = INIT;\n\n\t// Initialize the error state:\n\tthis._errname = '';\n\n\t// Extract various options:\n\tthis._comment = options.comment || opts.comment;\n\tthis._decimal = options.decimal || opts.decimal;\n\tthis._delimiter = options.delimiter || opts.delimiter;\n\tthis._doublequote = ( options.doublequote === void 0 ) ? opts.doublequote : options.doublequote;\n\tthis._escape = options.escape || opts.escape;\n\tthis._false = options.false || opts.false; // TODO: convert to regexp\n\tthis._missing = options.missing || opts.missing; // TODO: convert to regexp\n\tthis._newline = options.newline || opts.newline;\n\tthis._quote = options.quote || opts.quote;\n\tthis._quoting = ( options.quoting === void 0 ) ? opts.quoting : options.quoting;\n\tthis._schema = options.schema || opts.schema;\n\tthis._strict = ( options.strict === void 0 ) ? opts.strict : options.strict;\n\tthis._thousands = options.thousands || opts.thousands;\n\tthis._trim = ( options.trim === void 0 ) ? opts.trim : options.trim;\n\tthis._trimComment = ( options.trimComment === void 0 ) ? opts.trimComment : options.trimComment;\n\tthis._trimNonNumeric = ( options.trimNonNumeric === void 0 ) ? opts.trimNonNumeric : options.trimNumeric;\n\tthis._true = options.true || opts.true; // TODO: convert to regexp\n\tthis._whitespace = options.whitespace || opts.whitespace; // TODO: convert to regexp\n\n\tthis._onClose = options.onClose || opts.onClose;\n\tthis._onColumn = options.onColumn || opts.onColumn;\n\tthis._onComment = options.onComment || opts.onComment;\n\tthis._onRow = options.onRow || opts.onRow;\n\n\tthis._onError = options.onError || opts.onError;\n\tthis._onWarn = options.onWarn || opts.onWarn;\n\n\tthis._commentLength = this._comment.length;\n\tthis._commentLastIndex = this._commentLength - 1;\n\n\tthis._delimiterLength = this._delimiter.length;\n\tthis._delimiterLastIndex = this._delimiterLength - 1;\n\n\tthis._escapeLength = this._escape.length;\n\tthis._escapeLastIndex = this._escapeLength - 1;\n\n\tthis._newlineLength = this._newline.length;\n\tthis._newlineLastIndex = this._newlineLength - 1;\n\n\tthis._quoteLength = this._quote.length;\n\tthis._quoteLastIndex = this._quoteLength - 1;\n\n\t// Initialize state processors...\n\tthis._states = states( this ); // NOTE: this should come after all other initialization!\n\n\treturn this;\n}\n\n/**\n* Updates state by adding a processed character to an internal buffer.\n*\n* @private\n* @name _push\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} ch - character\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_push', function push( ch ) {\n\tvar buf = this._buffer;\n\n\t// Increment the internal buffer pointer:\n\tthis._cursor += 1;\n\n\t// Only expand the internal buffer if we've run out of previously allocated memory...\n\tif ( this._cursor >= buf.length ) {\n\t\tbuf.push( ch );\n\t\tdebug( 'Internal buffer size increased. Length: %d.', buf.length );\n\t} else {\n\t\t// Reuse existing memory:\n\t\tbuf[ this._cursor ] = ch;\n\t}\n\tdebug( 'Cursor: %d. Push: %s', this._cursor, ch );\n\treturn this;\n});\n\n/**\n* Rewinds the internal buffer cursor by a specified amount.\n*\n* @private\n* @name _rewind\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} N - number of elements to rewind\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_rewind', function rewind( N ) {\n\tthis._cursor -= N;\n\n\tdebug( 'Rewind: %d. Cursor: %d.', N, this._cursor );\n\treturn this;\n});\n\n/**\n* Copies a sequence of internal buffer elements to an earlier position in the buffer.\n*\n* @private\n* @name _copyWithin\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} target - starting position to which to copy elements\n* @param {NonNegativeInteger} start - staring index of the elements to copy (inclusive)\n* @param {NonNegativeInteger} N - number of elements to copy\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_copyWithin', function copyWithin( target, start, N ) {\n\tvar buf;\n\tvar i;\n\n\tbuf = this._buffer;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tbuf[ target+i ] = buf[ start+i ];\n\t}\n\treturn this;\n});\n\n/**\n* Resets the parser.\n*\n* @private\n* @name _reset\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_reset', function reset() {\n\t// Reset counters and indices:\n\tthis._col = 0;\n\tthis._cidx = 0;\n\tthis._qidx = -1;\n\tthis._eidx = -1;\n\n\t// Reset the parser state to attempting to parse the first field of the next record:\n\tthis._state = INIT;\n\n\t// Reset the buffer:\n\tthis._cursor = -1;\n\n\tdebug( 'Parser reset.' );\n\treturn this;\n});\n\n/**\n* Sets a field value in an internal row buffer.\n*\n* @private\n* @name _set\n* @memberof Parser.prototype\n* @type {Function}\n* @param {*} value - field value\n* @param {NonNegativeInteger} idx - field index\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_setField', function set( value, idx ) {\n\tvar buf = this._rowBuffer;\n\n\t// FIXME: as buffer may be provided from userland, use `set` accessor and consider using `@stdlib/utils/push` to allow support of dynamically resizing fixed length buffers\n\n\t// Only expand the row buffer if we've run out of previously allocated memory...\n\tif ( idx >= buf.length ) {\n\t\tbuf.push( value );\n\t\tdebug( 'Row buffer size increased. Length: %d.', buf.length );\n\t} else {\n\t\t// Reuse existing memory:\n\t\tbuf[ idx ] = value;\n\t}\n\treturn this;\n});\n\n/**\n* Returns a field value.\n*\n* @private\n* @name _getField\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} start - starting character index (inclusive)\n* @param {NonNegativeInteger} end - ending character index (inclusive)\n* @returns {string} field value\n*/\nsetReadOnly( Parser.prototype, '_getField', function get( start, end ) {\n\tvar buf;\n\tvar re;\n\tvar i;\n\n\tbuf = this._buffer;\n\ti = start;\n\tif ( this._trim ) {\n\t\tre = this._whitespace;\n\t\tfor ( ; i <= end; i++ ) {\n\t\t\tif ( re.test( buf[ i ] ) === false ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: presumably this is where we should perform any conversions/transformations\n\n\treturn buf.slice( i, end+1 ).join( '' );\n});\n\n/**\n* Returns the current row of values.\n*\n* @private\n* @name _getRow\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {ArrayLikeObject} row of values\n*/\nsetReadOnly( Parser.prototype, '_getRow', function get() {\n\tif ( this._rowBufferFLG ) {\n\t\treturn this._rowBuffer;\n\t}\n\t// Return a shallow copy to avoid mutating internal state:\n\treturn this._rowBuffer.slice( 0, this._col );\n});\n\n/**\n* Scans the internal buffer for a specified character sequence.\n*\n* ## Notes\n*\n* -   Given an internal buffer\n*\n*     ```text\n*     | ... | a | b |\n*     ```\n*\n*     search character sequence\n*\n*     ```text\n*     | a | b | c |\n*     ```\n*\n*     and `N` equal to `2`, the method will begin scanning from the position of `a` in the internal buffer above and compare to each element of the first `N` characters of the search character sequence.\n*\n*     This method is intended to be used in scenarios where we already know that an incoming character matches the last character of the search sequence, and we want to know whether the rest of the search sequence matches the most recently added elements in the internal buffer.\n*\n* @private\n* @name _scan\n* @memberof Parser.prototype\n* @type {Function}\n* @param {StringArray} search - character sequence\n* @param {NonNegativeInteger} N - number of characters to search\n* @returns {boolean} boolean indicating whether a match was found\n*/\nsetReadOnly( Parser.prototype, '_scan', function scan( search, N ) {\n\tvar buf;\n\tvar idx;\n\tvar i;\n\n\tbuf = this._buffer;\n\tidx = this._cursor - N + 1;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( buf[ idx+i ] !== search[ i ] ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ( i === N );\n});\n\n/**\n* Processes a field.\n*\n* @private\n* @name _onField\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onField', function onField() {\n\t// Extract the field value:\n\tvar v = this._getField( this._cidx, this._cursor );\n\n\t// Insert the field value into the row buffer:\n\tthis._setField( v, this._col );\n\n\t// Invoke a callback for receiving field values:\n\tthis._onColumn( v, this._row, this._col );\n\n\t// Increment the field counter to record that we've moved on to the next field:\n\tthis._col += 1;\n\n\t// Increment the index marking the beginning of the next field:\n\tthis._cidx = this._cursor + 1; // +1 as the cursor currently points to the last character in the current field, and, thus, the next field should start at the next index\n\n\t// Reset indices:\n\tthis._qidx = -1;\n\tthis._eidx = -1;\n\n\tdebug( 'New field. Line: %d. Field: %d. Value: %s', this._line+1, this._col, v );\n\treturn this;\n});\n\n/**\n* Processes a record.\n*\n* @private\n* @name _onRecord\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onRecord', function onRecord() {\n\t// FIXME: check for whether `onEmpty` should be invoked and/or handle blank lines\n\n\t// Extract the field value:\n\tvar v = this._getField( this._cidx, this._cursor );\n\n\t// Insert the field value into the row buffer:\n\tthis._setField( v, this._col );\n\n\t// Invoke a callback for receiving field values:\n\tthis._onColumn( v, this._row, this._col );\n\tthis._col += 1;\n\n\t// Invoke a callback for receiving rows:\n\tthis._onRow( this._getRow(), this._row, this._col );\n\tthis._row += 1;\n\tthis._line += 1;\n\n\tdebug( 'New record. Line: %d. Fields: %d.', this._line, this._col );\n\n\t// Reset the parser:\n\tthis._reset();\n\n\treturn this;\n});\n\n/**\n* Processes a commented row.\n*\n* @private\n* @name _onCommentedRow\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onCommentedRow', function onCommentedRow() {\n\tvar v;\n\n\t// Invoke a callback for receiving commented lines:\n\tif ( this._onComment ) {\n\t\tv = this._buffer.slice( 0, this._cursor+1 ).join( '' );\n\t\tif ( this._trimComment ) {\n\t\t\t// FIXME: trim the leading and trailing whitespace (e.g., using @stdlib/string/base/trim)\n\t\t}\n\t\tthis._onComment( v, this._line );\n\t\tdebug( 'New comment. Line: %d. Value: %s', this._line, v );\n\t}\n\t// Increment the counter for how many lines have been processed:\n\tthis._line += 1;\n\n\t// Reset the parser:\n\tthis._reset();\n\n\treturn this;\n});\n\n/**\n* Processes a closing quote sequence.\n*\n* @private\n* @name _onClosingQuote\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onClosingQuote', function onClosingQuote() {\n\t// Cache the cursor position marking the end of the closing quote sequence:\n\tthis._qidx = this._cursor;\n\treturn this;\n});\n\n/**\n* Processes an escape sequence.\n*\n* @private\n* @name _onEscape\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_onEscape', function onEscape() {\n\t// Cache the cursor position marking the end of the escape sequence:\n\tthis._eidx = this._cursor;\n\treturn this;\n});\n\n/**\n* Creates a parser exception.\n*\n* @private\n* @name _createException\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} name - exception name\n* @returns {Error} parser exception\n*/\nsetReadOnly( Parser.prototype, '_createException', function createException( name ) {\n\tvar err;\n\n\tswitch ( name ) {\n\tcase 'INVALID_CLOSING_QUOTE':\n\t\terr = new Error( format( 'unexpected error. Encountered an invalid record. Field %d on line %d contains a closing quote which is not immediately followed by a delimiter or newline.', this._col+1, this._line+1 ) );\n\t\tbreak;\n\tcase 'INVALID_ESCAPE':\n\t\terr = new Error( format( 'unexpected error. Encountered an invalid record. Field %d on line %d contains an escape sequence which is not immediately followed by a special character sequence.', this._col+1, this._line+1 ) );\n\t\tbreak;\n\tcase 'INVALID_QUOTED_ESCAPE':\n\t\terr = new Error( format( 'unexpected error. Encountered an invalid record. Field %d on line %d contains an escape sequence within a quoted field which is not immediately followed by a quote sequence.', this._col+1, this._line+1 ) );\n\t\tbreak;\n\tcase 'CLOSED':\n\t\terr = new Error( 'invalid operation. Parser is unable to parse new chunks, as the parser has been closed. To parse new chunks, create a new parser instance.' );\n\t\tbreak;\n\tdefault:\n\t\terr = new Error( 'invalid operation. Parser is in an unrecoverable error state. To parse new chunks, create a new parser instance.' );\n\t\tbreak;\n\t}\n\treturn err;\n});\n\n/**\n* Raises a parser warning.\n*\n* @private\n* @name _raiseWarning\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} name - exception name\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_raiseWarning', function raiseWarning( name ) {\n\tvar err;\n\n\tif ( this._onWarn ) {\n\t\terr = this._createException( name );\n\n\t\tdebug( 'Warning: %s', err.message );\n\t\tthis._onWarn( err );\n\t}\n\treturn this;\n});\n\n/**\n* Raises a parser exception.\n*\n* @private\n* @name _raiseException\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_raiseException', function raiseException() {\n\tvar err = this._createException( this._errname );\n\n\tdebug( 'Error: %s', err.message );\n\tthis._onError( err );\n\n\treturn this;\n});\n\n/**\n* Updates the parser state.\n*\n* @private\n* @name _changeState\n* @memberof Parser.prototype\n* @type {Function}\n* @param {NonNegativeInteger} state - state enumeration constant\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_changeState', function changeState( state ) {\n\tdebug( 'State transition: %s -> %s.', enum2state[ this._state ], enum2state[ state ] );\n\n\tif ( this._state === COMMENT ) {\n\t\tthis._onCommentedRow();\n\t\tthis._state = state;\n\t\treturn this;\n\t}\n\tswitch ( state ) { // eslint-disable-line default-case\n\tcase CLOSED:\n\t\tthis._close();\n\t\tbreak;\n\tcase COMMENT:\n\t\tbreak;\n\tcase ERROR:\n\t\tthis._raiseException();\n\t\tbreak;\n\tcase ESCAPE:\n\t\tthis._onEscape();\n\t\tbreak;\n\tcase FIELD:\n\t\tif ( this._state !== ESCAPE ) {\n\t\t\tthis._onField();\n\t\t}\n\t\tbreak;\n\tcase INIT:\n\t\tthis._onRecord();\n\t\tbreak;\n\tcase QUOTE_END:\n\t\tthis._onClosingQuote();\n\t\tbreak;\n\tcase QUOTED_ESCAPE:\n\t\tthis._onEscape();\n\t\tbreak;\n\tcase QUOTED_FIELD:\n\t\tbreak;\n\t}\n\tthis._state = state;\n\treturn this;\n});\n\n/**\n* Sets the parser's error state.\n*\n* @private\n* @name _setErrorState\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} name - error name\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_setErrorState', function setErrorState( name ) {\n\tif ( name ) {\n\t\tdebug( 'Error: %s.', name );\n\t} else {\n\t\tdebug( 'Reset error state.' );\n\t}\n\tthis._errname = name;\n\treturn this;\n});\n\n/**\n* Closes the parser.\n*\n* @private\n* @name _close\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*/\nsetReadOnly( Parser.prototype, '_close', function close() {\n\tvar state;\n\tvar v;\n\n\tif ( this.done ) {\n\t\tthis._setErrorState( CLOSED )._changeState( ERROR );\n\t\treturn this;\n\t}\n\tif ( this._cursor >= 0 ) {\n\t\tstate = this._state;\n\t\tif ( state === INIT || state === FIELD || state === QUOTE_END ) {\n\t\t\t// If the current state is \"field\" or \"quote end\", we're in a valid state and can simply transition to our initial state to indicate that we've processed a record:\n\t\t\tthis._changeState( INIT )._onClose();\n\t\t} else {\n\t\t\t// Check if we were able to process part of a row...\n\t\t\tif ( this._col ) {\n\t\t\t\t// This may be an incomplete row!!!\n\t\t\t\tthis._onRow( this._getRow(), this._row, this._col );\n\t\t\t}\n\t\t\t// Extract however much of the current field we were able to process:\n\t\t\tv = this._buffer.slice( this._cidx, this._cursor+1 ).join( '' );\n\n\t\t\t// Return the unfinished field to the client (although this may not be equal to the original character sequence, as escape sequences may have already been stripped!):\n\t\t\tdebug( 'Flush: %s', v );\n\t\t\tthis._onClose( v );\n\t\t}\n\t} else {\n\t\tthis._onClose();\n\t}\n\tdebug( 'Closed.' );\n\treturn this;\n});\n\n/**\n* Parses the next chunk.\n*\n* @name next\n* @memberof Parser.prototype\n* @type {Function}\n* @param {string} chunk - chunk\n* @throws {Error} unable to parse new chunks\n* @throws {Error} invalid field\n* @throws {Error} invalid record\n* @returns {Parser} parser instance\n*\n* @example\n* var parser = new Parser();\n*\n* // ...\n*\n* parser.next( '1,2,3,4\\n' );\n*\n* // ...\n*\n* parser.next( '5,6,7,8\\n' );\n*\n* // ...\n*\n* parser.next( '9,10,11,12\\n' );\n*/\nsetReadOnly( Parser.prototype, 'next', function next( chunk ) {\n\tvar states;\n\tvar i;\n\n\tdebug( 'Chunk: %s', chunk );\n\n\tif ( this.done ) {\n\t\tthis._setErrorState( CLOSED )._changeState( ERROR );\n\t\treturn this;\n\t}\n\tstates = this._states;\n\tfor ( i = 0; i < chunk.length; i++ ) {\n\t\tstates[ this._state ]( chunk[ i ] );\n\t\tif ( this._state === ERROR ) {\n\t\t\treturn this;\n\t\t}\n\t}\n\treturn this;\n});\n\n/**\n* Closes the parser.\n*\n* @name close\n* @memberof Parser.prototype\n* @type {Function}\n* @returns {Parser} parser instance\n*\n* @example\n* var parser = new Parser();\n*\n* // ...\n*\n* parser.next( '1,2,3,4\\n' );\n*\n* // ...\n*\n* parser.next( '5,6,7,8\\n' );\n*\n* // ...\n*\n* parser.next( '9,10,11,12\\n' );\n*\n* // ...\n*\n* parser.close();\n*/\nsetReadOnly( Parser.prototype, 'close', function close() {\n\tif ( this.done ) {\n\t\treturn this;\n\t}\n\tthis._changeState( CLOSED );\n\treturn this;\n});\n\n/**\n* Boolean indicating whether a parser is able to process new chunks.\n*\n* @name done\n* @memberof Parser.prototype\n* @readonly\n* @type {boolean}\n*\n* @example\n* var parser = new Parser();\n*\n* // ...\n*\n* parser.next( '1,2,3,4\\n' );\n*\n* // ...\n*\n* parser.next( '5,6,7,8\\n' );\n*\n* // ...\n*\n* parser.next( '9,10,11,12\\n' );\n*\n* // ...\n*\n* parser.close();\n*\n* // ...\n*\n* var bool = parser.done;\n* // returns true\n*/\nsetReadOnlyAccessor( Parser.prototype, 'done', function get() {\n\treturn ( this._state === CLOSED ) || ( this._state === ERROR );\n});\n\n\n// EXPORTS //\n\nexport default Parser;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport defineProperty from '@stdlib/utils-define-property' ;\n\n\n// MAIN //\n\n/**\n* Defines a non-enumerable read-only accessor.\n*\n* @param {Object} obj - object on which to define the property\n* @param {(string|symbol)} prop - property name\n* @param {Function} getter - accessor\n*\n* @example\n* function getter() {\n*     return 'bar';\n* }\n*\n* var obj = {};\n*\n* setNonEnumerableReadOnlyAccessor( obj, 'foo', getter );\n*\n* try {\n*     obj.foo = 'boop';\n* } catch ( err ) {\n*     console.error( err.message );\n* }\n*/\nfunction setNonEnumerableReadOnlyAccessor( obj, prop, getter ) { // eslint-disable-line id-length\n\tdefineProperty( obj, prop, {\n\t\t'configurable': false,\n\t\t'enumerable': false,\n\t\t'get': getter\n\t});\n}\n\n\n// EXPORTS //\n\nexport default setNonEnumerableReadOnlyAccessor;\n"],"names":["defineProperty","main","Object","objectProtoype","prototype","toStr","toString","defineGetter","__defineGetter__","defineSetter","__defineSetter__","lookupGetter","__lookupGetter__","lookupSetter","__lookupSetter__","err","hasDefinePropertySupport","builtin","obj","prop","descriptor","hasValue","hasGet","hasSet","call","TypeError","__proto__","value","Error","get","set","defineProperty$1","setNonEnumerableReadOnly","configurable","enumerable","writable","Bool","Boolean","fmtprodmsg","i","a","arguments","c","u","length","encodeURIComponent","noop","throwError","defaults","comment","decimal","delimiter","doublequote","escape","false","missing","newline","onClose","onColumn","onComment","onError","onWarn","onRow","quote","quoting","rowBuffer","schema","strict","thousands","trim","trimComment","trimNonNumeric","true","whitespace","state2enum","out","enum2state","table","CLOSED","INIT","ERROR","max","x","y","FIELD","ESCAPE","QUOTED_FIELD","COMMENT","QUOTE_END","QUOTED_ESCAPE","closed","parser","_changeState","newlineLastIndex","_newlineLastIndex","_newline","ch","_scan","_rewind","_push","delimiterLastIndex","commentLastIndex","escapeLastIndex","escapeLength","_delimiterLastIndex","_delimiter","_commentLastIndex","_comment","_escapeLastIndex","_escapeLength","_escape","_strict","maximum","cursor","_cursor","idx","_eidx","d","_copyWithin","_setErrorState","_raiseWarning","error","field","quoteLastIndex","_quoteLastIndex","_quote","_quoting","_cidx","init","quote_end","_doublequote","_qidx","quoted_escape","quoted_field","states","push","debug","Parser","options","opts","this","_buffer","_rowBufferFLG","_rowBuffer","_col","_row","_line","_state","_errname","_decimal","_false","_missing","_schema","_thousands","_trim","_trimComment","_trimNonNumeric","trimNumeric","_true","_whitespace","_onClose","_onColumn","_onComment","_onRow","_onError","_onWarn","_commentLength","_delimiterLength","_newlineLength","_quoteLength","_states","buf","N","setReadOnly","target","start","end","re","test","slice","join","search","v","_getField","_setField","_getRow","_reset","name","format","_createException","message","state","_onCommentedRow","_close","_raiseException","_onEscape","_onField","_onRecord","_onClosingQuote","done","chunk"],"mappings":"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"}